<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXE4B093585C3446779125DDB1EA20E145">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">SpongeZoneTools</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Script" referent="RBX06F1FB0E1407436D8FE8561996F67A90">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local pluginSingleton = require(script.Parent.PluginSingleton)
pluginSingleton:_Initialize(plugin)

local spongeZoneToolbar = plugin:CreateToolbar("InfiltrationEngine // SpongeAugments")

local allTools = {
	AttributeImporter = script.Parent.AttributeImporter.Main,
	ToggleGroupVis = script.Parent.ToggleGroupVis.Main,
	OneClickTools = script.Parent.OneClickTools.Main,
}

local settingsModule = script.Parent.Settings.Main

local topLevelButtons = {}

local function IconFromInfo(info)
	if settings().Studio.Theme.Name == "Light" then
		return info.LightIconAssetID or info.IconAssetID or "rbxassetid://106247740984287"
	else
		return info.IconAssetID or info.LightIconAssetID or "rbxassetid://106247740984287"
	end
end

local function CreateTopLevelButton(info)
	local button = spongeZoneToolbar:CreateButton(
		`SZT_IE_Toolbar_{info.ID}`,
		info.Tooltip,
		IconFromInfo(info),
		info.Text or info.ID
	)
	
	if info.BuildMenu ~= nil then
		info.BuildMenu()
	end
	
	if info.RethemeMenu ~= nil then
		settings().Studio.Theme.Changed:Connect(info.RethemeMenu)
	end
	
	button.Click:Connect(info.ClickedCallback)
	topLevelButtons[info.ID] = { Info = info, Button = button }
end

local function BuildPluginToolbar(printInits)
	printInits = printInits or false
	for k, v in pairs(allTools) do
		local toolDetails = require(v)
		
		if toolDetails.SubActions ~= nil then
			for subactionName, subaction in pairs(toolDetails.SubActions) do
				if printInits then print(`Initializing SpongeZone tool {subactionName}...`) end
				CreateTopLevelButton(subaction)
			end
		end
		
		if toolDetails.SubActionsOnly then continue end
		
		if printInits then print(`Initializing SpongeZone tool {k}...`) end
		
		CreateTopLevelButton(toolDetails)
	end
	
	-- Special treatment so it shows up last and has a special init message
	if printInits then print("Initializing Settings module...") end
	CreateTopLevelButton(require(settingsModule))
end

local function WarnIfUnknownTheme()
	if settings().Studio.Theme.Name ~= "Light" and settings().Studio.Theme.Name ~= "Dark" then
		warn("Using unknown studio theme, defaulting to dark mode icons.")
	end
end

local function RethemeTopLevelButtons()
	WarnIfUnknownTheme()
	
	for id, buttonInfo in pairs(topLevelButtons) do
		buttonInfo.Button.Icon = IconFromInfo(buttonInfo.Info)
	end
	
	warn("Due to how plugins function (arbitrary roblox limitations) some icons will be broken until studio is restarted!")
end

BuildPluginToolbar(true)
WarnIfUnknownTheme()

settings().Studio.ThemeChanged:Connect(RethemeTopLevelButtons)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{BA25A1CB-E014-4DF4-B49E-AEDDD88D8479}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX80AB061272C945198EB427376CA9EF35">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local pluginSingleton = require(script.Parent.PluginSingleton)

local ChangeHistoryService = game:GetService("ChangeHistoryService")
local SelectionService = game:GetService("Selection")

local pluginMenus = {}

local ToolsCommon = {}

local function RethemePluginElements()
	for _, menuInfo in pairs(pluginMenus) do
		menuInfo.Menu.Icon = ToolsCommon:SelectIcon(menuInfo.Icons.Dark, menuInfo.Icons.Light)
	end
end

function ToolsCommon:SelectIcon(dark, light)
	if self:CurrentStudioTheme() == "Light" then
		return light or dark or "rbxassetid://106247740984287"
	else
		return dark or light or "rbxassetid://106247740984287"
	end
end

function ToolsCommon:CurrentStudioTheme() return settings().Studio.Theme.Name end

function ToolsCommon:CreatePluginMenu(id, text, darkIconId, lightIconId)
	local menu = pluginSingleton:CreatePluginMenu(`SZT_IE_Menu_{id}`, text, self:SelectIcon(darkIconId, lightIconId))
	pluginMenus[id] = { Menu = menu, Icons = { Dark = darkIconId, Light = lightIconId } }
	return menu
end

function ToolsCommon:CreatePluginAction(id, text, tooltip, darkIconId, lightIconId, allowBinding)
	allowBinding = allowBinding ~= nil and allowBinding or true
	local action = pluginSingleton:CreatePluginAction(`SZT_IE_Action_{id}`, text, tooltip, ToolsCommon:SelectIcon(darkIconId, lightIconId), allowBinding)
	return action
end

function ToolsCommon:GetPluginSetting(settingKey)
	return pluginSingleton:GetSetting(`SZT_IE_{settingKey}`)
end

function ToolsCommon:SetPluginSetting(settingKey, value)
	pluginSingleton:SetSetting(`SZT_IE_{settingKey}`, value)
	return self:GetPluginSetting(settingKey) == value
end

function ToolsCommon:GetGridSize()
	return pluginSingleton:GetGridSize()
end

function ToolsCommon:RecordChanges(name: string)
	local recording = ChangeHistoryService:TryBeginRecording(name)
	if recording == nil then warn("Failed to initialize history recording, doing nothing") return end
	return recording
end

function ToolsCommon:CommitChanges(recording: string, enum: Enum.FinishRecordingOperation?)
	if enum == nil then enum = Enum.FinishRecordingOperation.Commit end
	ChangeHistoryService:FinishRecording(recording, enum)
end

function ToolsCommon:GetSelection() return SelectionService:Get() end

function ToolsCommon:LevelFolder()
	return workspace:FindFirstChild("DebugMission") or workspace:FindFirstChild("Level")
end

function ToolsCommon:NullableDescendantOf(instanceDescendant: Instance, childPath: {string}, searchRoot: Instance?)
	searchRoot = searchRoot or workspace
	local comparing = nil
	for _, name in pairs(childPath) do
		comparing = (comparing or searchRoot):FindFirstChild(name)
		if comparing == nil then break end
	end
	if comparing == nil then return false end
	return comparing:IsAncestorOf(instanceDescendant)
end

function ToolsCommon:AncestryCheck(instanceDescendant, ancestryNames, descendantCheck, idx)
	descendantCheck = if descendantCheck == nil then false else true
	idx = idx or #ancestryNames
	local parentName = ancestryNames[idx]
	if parentName == nil then return true end
	if instanceDescendant.Parent == nil then return false end
	if instanceDescendant.Parent == workspace then return false end
	if instanceDescendant.Parent.Name == parentName then return ToolsCommon:AncestryCheck(instanceDescendant.Parent, ancestryNames, descendantCheck, idx-1) end
	if instanceDescendant.Parent.Name ~= parentName and descendantCheck then return ToolsCommon:AncestryCheck(instanceDescendant.Parent, ancestryNames, descendantCheck, idx) end
	return false
end

function ToolsCommon:InstanceIsAny(instance: Instance, classNames: {string})
	for _, className in pairs(classNames) do
		if instance:IsA(className) then return true end
	end
	return false
end

function ToolsCommon:FindFirstChildWithNameAndClass(parent: Instance, name: string, classname: string): classname?
	for _, child in pairs(parent:GetChildren()) do
		if child.Name == name and child:IsA(classname) then return child end
	end
	return nil
end

function ToolsCommon:TableMerge(tblTo: {any}, tblFrom: {any}, preferExisting: boolean?)
	if tblTo == nil then return tblFrom or {} end
	if tblFrom == nil then return tblTo or {} end
	preferExisting = preferExisting or true
	for k, v in pairs(tblFrom) do
		if tblTo[k] == nil then
			tblTo[k] = v
			continue
		end
		if preferExisting then
			continue
		end
		tblTo[k] = v
	end
	return tblTo
end

function ToolsCommon:TableSlice(tblSrc: {any}, sliceStart: number, sliceEnd: number)
	local tblTo = {}
	for i=sliceStart, sliceEnd, 1 do
		tblTo[#tblTo+1] = tblSrc[i]
	end
	return tblTo
end

settings().Studio.ThemeChanged:Connect(RethemePluginElements)

return ToolsCommon]]></ProtectedString>
				<string name="ScriptGuid">{2D5EAC34-8CC9-43F4-B456-D43738C01990}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ToolsCommon</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBX31B223ED82EA4727AEAEECE1FC2072F9">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local PluginSingleton = {}

local _plugin = nil
function PluginSingleton:_Initialize(singleton)
	_plugin = singleton
end

function PluginSingleton:CreatePluginMenu(id, text, iconId)
	return _plugin:CreatePluginMenu(id, text, iconId)
end

function PluginSingleton:CreatePluginAction(id, text, tooltip, iconId, allowBinding)
	return _plugin:CreatePluginAction(id, text, tooltip, iconId, allowBinding)
end

function PluginSingleton:GetSetting(settingKey)
	return _plugin:GetSetting(settingKey)
end

function PluginSingleton:SetSetting(settingKey, value)
	_plugin:SetSetting(settingKey, value)
end

function PluginSingleton:GetGridSize()
	return _plugin.GridSize
end

function PluginSingleton:Underlying()
	return _plugin
end

return PluginSingleton]]></ProtectedString>
				<string name="ScriptGuid">{0B52CE3C-5989-42D0-AC59-A04E1E3A6836}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">PluginSingleton</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBXB140981FA1B842E69C0DF32458F3FB3A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">ToggleGroupVis</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXCC2BB1C47C1A41E4B8776BF725C2A484">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.ToolsCommon)

local GROUP_VIS_ATTR_NAME = "_SpongeGroupVisibility"
local ELMNT_VIS_ATTR_NAME = "_SpongeElmntVisibility"

local function IsGroup(inst: Instance)
	local instType = inst.ClassName
	return instType == "Folder" or instType == "Model", instType
end

local function StoreElementProperty(element: Instance, property: string, newVal: any)
	element:SetAttribute(`_SpongeElmnt{property}`, element[property])
	element[property] = newVal
end

local function RestoreElementProperty(element: Instance, property: string, expected: any)
	if element[property] ~= expected then
		warn(`{element.Name}{property} set to unexpected value after being toggled, assuming new value to be intentional`)
		return element[property]
	end
	local stored = element:GetAttribute(`_SpongeElmnt{property}`)
	element[property] = stored
	return stored
end

local function ToggleElementVisibility(element: BasePart, nextVisState: boolean)
	if nextVisState == element:GetAttribute(ELMNT_VIS_ATTR_NAME) then
		--print(`{element.Name} already in desired state, leaving as-is`)
		return
	end

	if nextVisState and (element:GetAttribute(ELMNT_VIS_ATTR_NAME) == nil) then
		warn("Element in disabled visgroup had no visibility metadata - likely added after disable. Skipping")
		return
	end

	if nextVisState == false then
		StoreElementProperty(element, "Transparency", 1)
		StoreElementProperty(element, "Locked",       true)
		StoreElementProperty(element, "CanCollide",   false)
		StoreElementProperty(element, "CanTouch",     false)
		StoreElementProperty(element, "CanQuery",     false)
	else
		RestoreElementProperty(element, "Transparency", 1)
		RestoreElementProperty(element, "Locked",       true)
		RestoreElementProperty(element, "CanCollide",   false)
		RestoreElementProperty(element, "CanTouch",     false)
		RestoreElementProperty(element, "CanQuery",     false)
	end
	
	element:SetAttribute(ELMNT_VIS_ATTR_NAME, nextVisState)
end

local function CalculateGroupParentsRecurse(parent: Instance, tbl: table?)
	tbl = tbl or {}
	if parent == nil then warn("Group's root parent was nil!?") return tbl end
	if parent == workspace.Parent then return tbl end
	if IsGroup(parent) then
		if parent:GetAttribute(GROUP_VIS_ATTR_NAME) == nil then
			parent:SetAttribute(GROUP_VIS_ATTR_NAME, true)
		end
		tbl[#tbl+1] = parent:GetAttribute(GROUP_VIS_ATTR_NAME)
	end
	return CalculateGroupParentsRecurse(parent.Parent, tbl)
end

local function CalculateGroupVisibility(group)
	local visTbl = CalculateGroupParentsRecurse(group)
	for _, v in pairs(visTbl) do
		if not v then return false end
	end
	return true
end

local function ToggleGroupVisibility(group: Instance, invert: boolean)
	-- Invert the selected group's visibility
	-- Assume group is visible if no group vis is set
	if group:GetAttribute(GROUP_VIS_ATTR_NAME) == nil then group:SetAttribute(GROUP_VIS_ATTR_NAME, true) end
	if invert then group:SetAttribute(GROUP_VIS_ATTR_NAME, not group:GetAttribute(GROUP_VIS_ATTR_NAME)) end

	local thisGroupIsVisible = CalculateGroupVisibility(group)

	for _, child in pairs(group:GetChildren()) do
		local isBasePart = child:IsA("BasePart")
		local isGroup = IsGroup(child)
		if not (isBasePart or isGroup) then continue end
		if isBasePart then ToggleElementVisibility(child, thisGroupIsVisible) end 
		if isGroup then ToggleGroupVisibility(child, false) end
	end
end

local function GroupVisTogglePressed()
	local selection = common:GetSelection()

	local selectionIsValid = true
	for instName, inst in pairs(selection) do
		local instValid, instType = IsGroup(inst)
		if not instValid then
			warn(`GroupVisToggle only works on Models & Folders, deselect {instType} {instName} before running!`)
			selectionIsValid = false
		end
	end

	if not selectionIsValid then return end

	local recording = common:RecordChanges("Toggle Group Visibility")
	if not recording then return end

	for _, inst in pairs(selection) do
		ToggleGroupVisibility(inst, true)
	end

	common:CommitChanges(recording)

end

return {
	ClickedCallback = GroupVisTogglePressed,
	ID = "Toggle Group Visibility", 
	Tooltip = "Toggle the visibility of a folder/model", 
	IconAssetID = "rbxassetid://86288177650040",
	LightIconAssetID = "rbxassetid://137463386400446"
}]]></ProtectedString>
					<string name="ScriptGuid">{7B825C44-7342-4A3D-9FBE-7FC60ED35674}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX5919143A4702411F9D002668A286B71E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">OneClickTools</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX18272F2552884B1F9DDE2B402F83D389">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.ToolsCommon)
local pluginSettingsKeys = require(script.Parent.Parent.Settings.SettingsKeys)

local oneClickMenuEnabled = common:GetPluginSetting(pluginSettingsKeys.ONE_CLICK_ENABLED)
if oneClickMenuEnabled == nil then oneClickMenuEnabled = true end

local oneClickMenuDisabled = not oneClickMenuEnabled

local toolsList = {
	CellFixup = script.Parent.CellFixup.Main,
	CustomPropBaseGen = script.Parent.CustomPropBaseGen.Main,
	GenSlopePart = script.Parent.GenSlopePart.Main,
	ReorganizeContents = script.Parent.ReorganizeContents.Main
}

local subActions = {}
for k, tool in pairs(toolsList) do
	subActions[k] = require(tool)
end

local oneClickMenu: PluginMenu? = nil

local function BuildMenu()
	oneClickMenu = common:CreatePluginMenu("OneClickTools", "One-Click Tools", "rbxassetid://125187645185104", "rbxassetid://80115599628137")
	
	for toolName, toolModule in pairs(toolsList) do
		print(`\tInitializing {toolName}...`)
		
		local actionInfo = require(toolModule)
		local toolAction = common:CreatePluginAction(`OCT_{actionInfo.ID}`, actionInfo.ID, actionInfo.Tooltip, actionInfo.IconAssetID, actionInfo.LightIconAssetID)
		
		toolAction.Triggered:Connect(actionInfo.ClickedCallback)
		oneClickMenu:AddAction(toolAction)
	end
end

local function OpenWindow()
	oneClickMenu:ShowAsync()
end

if not oneClickMenuDisabled then subActions = nil end

return {
	SubActionsOnly = oneClickMenuDisabled,
	SubActions = subActions,
	
	ID = "One-Click Tools",
	Tooltip = "A collection of tools activated by a single click.\nExists to avoid cluttering your plugin bar :3",
	IconAssetID = "rbxassetid://125187645185104",
	LightIconAssetID = "rbxassetid://80115599628137",
	
	ClickedCallback = OpenWindow,
	BuildMenu = BuildMenu
}]]></ProtectedString>
					<string name="ScriptGuid">{311C54E9-667F-47AD-8660-BEFB18238E0C}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX5491DE4201304C05BCF919ACFCDA08D3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">CellFixup</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXCAD177EF30304D66A4343FDE6E9A2095">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.Parent.ToolsCommon)

-- Hash politely borrowed from the official Cell tools
local function hashName(name)
	if name == "Default" then
		return Color3.new(0, 0, 0)
	end

	local h = 5^7
	local n = 0
	for i = 1, #name do
		n = (n * 257 + string.byte(name, i, i)) % h 
	end
	local color = Color3.fromHSV((n % 1000) / 1000, 0.5, 0.5)
	return color
end

local function FixCell(cell, cellPart, cellCol)
	cellPart.Color = cellCol
	cellPart.CastShadow = false
	cellPart.Material = Enum.Material.Plastic
	cellPart.Transparency = 0.5
	cellPart.TopSurface = Enum.SurfaceType.Studs
	cellPart.BottomSurface = Enum.SurfaceType.Inlet

	if cellPart.Shape ~= Enum.PartType.Block then warn(`Cell Part {cell.Name}.{cellPart.Name} is non-block shape {tostring(cellPart.Shape)}!`) end
end

local function LinkTexture(normal)
	local tex = Instance.new("Texture")
	tex.Texture = "rbxassetid://124542772943020"
	tex.StudsPerTileU = 3
	tex.StudsPerTileV = 1
	tex.Face = normal
	tex.Name = `Texture{normal.Name}`
	return tex
end

local function FixLink(linkPart)
	linkPart.Color = Color3.fromRGB(127, 63, 65)
	linkPart.CastShadow = false
	linkPart.Material = Enum.Material.Plastic
	linkPart.Transparency = 0.5
	linkPart.TopSurface = Enum.SurfaceType.Smooth
	linkPart.BottomSurface = Enum.SurfaceType.Smooth

	if linkPart:FindFirstChild("TextureFront") == nil then
		local frontTex = LinkTexture(Enum.NormalId.Front)
		frontTex.Parent = linkPart
	end

	if linkPart:FindFirstChild("TextureBack") == nil then
		local backTex = LinkTexture(Enum.NormalId.Back)
		backTex.Parent = linkPart
	end

	for k, v in next, linkPart:GetChildren() do
		if typeof(v) ~= "Instance" then continue end
		if v.Name == "TextureFront" then continue end
		if v.Name == "TextureBack" then continue end
		v:Destroy()
	end
end

local function CellFixup()
	local missionFolder = common:LevelFolder()
	if missionFolder == nil then warn("Failed to find Custom Mission folder!") return end
	
	if missionFolder:FindFirstChild("Cells") == nil then warn("Custom Mission folder does not contain Cells folder!") return end
	
	local recording = common:RecordChanges("Cell Fixup")
	if not recording then return end
	
	for _, cell in next, missionFolder.Cells:GetChildren() do
		local cellColour = hashName(cell.Name)
		if cell.Name == "Links" then
			for _, linkPart in next, cell:GetChildren() do
				if not linkPart:IsA("BasePart") then continue end
				FixLink(linkPart)
			end
		else
			for _, cellPart in next, cell:GetChildren() do
				if not cellPart:IsA("BasePart") then continue end
				FixCell(cell, cellPart, cellColour)
			end
		end
	end
	
	common:CommitChanges(recording)
end

return {
	ClickedCallback = CellFixup,
	ID = "Cell Fixup",
	Tooltip = "Fix cell styling",
	IconAssetID = "rbxassetid://115706109343056",
	LightIconAssetID = "rbxassetid://95343720267369"
}]]></ProtectedString>
						<string name="ScriptGuid">{F691E76A-0216-4C85-BF84-519152CBD9F2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB51C3324470340FB9B9FBAD23F048D05">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">CustomPropBaseGen</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE0D0804A60A24028AF2252D88FD436F3">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.Parent.ToolsCommon)

local function BaseGen()
	
	local recording = common:RecordChanges("Generate Prop Base")
	if not recording then return end
	
	for _, v in pairs(common:GetSelection()) do
		if not v:IsA("Model") then warn(`Selection {v.Parent.Name}.{v.Name} is not a Model! Skipping`) continue end
		
		local basePart = common:FindFirstChildWithNameAndClass(v, "Base", "BasePart") 
		
		if basePart ~= nil then
			-- Ignore existing Base when getting bounds
			basePart.Parent = nil
		end
		
		local transform, size = v:GetBoundingBox()
		
		basePart = basePart or Instance.new("Part")
		basePart.Parent = v
		basePart.Transparency = 1
		basePart.CFrame = transform
		basePart.Size = size
		basePart.Name = "Base"
		basePart.Anchored = true
		
		basePart.TopSurface = Enum.SurfaceType.Smooth
		basePart.BottomSurface = Enum.SurfaceType.Smooth
		
	end
	
	common:CommitChanges(recording)
	
end

return {
	ClickedCallback = BaseGen,
	ID = "Generate Prop Base",
	Tooltip = "Generate the 'Base' part for the selected custom prop",
	IconAssetID = "rbxassetid://73246176602542",
	LightIconAssetID = "rbxassetid://101352653431755"
}]]></ProtectedString>
						<string name="ScriptGuid">{CAAC927D-AFB9-44EF-A1CF-2D4715B27B47}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX8CECD6C871B94F5E8DFCB83B66A82CEB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">ReorganizeContents</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX88DEB3B9292349C68FA8625C758F6C56">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.Parent.ToolsCommon)

local function FakeChild(fakeParent, name)
	local fake = fakeParent:FindFirstChild(name)
	if fake ~= nil then return fake end
	
	fake = Instance.new("Folder")
	fake.Parent = fakeParent
	fake.Name = name
	return fake
end

local function ReorganizeContents()
	
	local recording = common:RecordChanges("Generate Prop Base #1")
	if not recording then return end
	
	local fakeParent = Instance.new("Part")
	fakeParent.Parent = workspace
	
	for _, parent in ipairs(common:GetSelection()) do
		local vChildren = parent:GetChildren()
		table.sort(vChildren, function(c1, c2) return c1.Name:lower() < c2.Name:lower() end)
		
		for _, child in ipairs(vChildren) do
			print(child.Name)
			child.Parent = FakeChild(fakeParent, child.Name)
		end
		
		for _, nameFolder in ipairs(fakeParent:GetChildren()) do
			for _, child in ipairs(nameFolder:GetChildren()) do
				local newChild = child:Clone()
				newChild.Parent = parent
			end
		end
		
	end
	
	fakeParent:Destroy()
	
	common:CommitChanges(recording)
	
end

return {
	ClickedCallback = ReorganizeContents,
	ID = "Child Organizer",
	Tooltip = "For each selected instance, reorganizes it's children to be listed in alphabetical order",
	IconAssetID = "rbxassetid://73267947291883",
	LightIconAssetID = "rbxassetid://96120579208421"
}]]></ProtectedString>
						<string name="ScriptGuid">{E18944E5-E01A-4129-9F65-BB85E1F4FC50}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX5FB1DF5DAA794757AE5A19F3DF20A423">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">GenSlopePart</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXBAD97FCD5ECB48229680AC30976A07C1">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.Parent.ToolsCommon)

local function InstanceIsWedge(instance: Instance)
	return instance:IsA("WedgePart") or instance:IsA("Part") and instance.Shape == Enum.PartType.Wedge
end

local function GenSlopePart(wedge: BasePart)
	
	local slopePart = wedge:Clone()
	slopePart.Parent = wedge.Parent
	slopePart.Shape = Enum.PartType.Block
	
	-- For some forsaken reason, Instance.new("Part") generates a part with inlets/studs
	slopePart.TopSurface = Enum.SurfaceType.Smooth
	slopePart.BottomSurface = Enum.SurfaceType.Smooth
	
	slopePart.Size = Vector3.new( wedge.Size.X, 0.5, math.sqrt(wedge.Size.Y^2 + wedge.Size.Z^2) )
	
	slopePart.CFrame = slopePart.CFrame * CFrame.Angles(math.atan2(wedge.Size.Y, wedge.Size.Z), 0, 0):Inverse()
	
end

local function GenSlopeParts()
	
	local recording = common:RecordChanges("Generate Slope Part(s)")
	if not recording then return end
	
	for _, selected in ipairs(common:GetSelection()) do
		if not InstanceIsWedge(selected) then warn(`Selection {selected.Name} isn't a Wedge! Skipping`) continue end
		GenSlopePart(selected)
	end
	
	common:CommitChanges(recording)
	
end

return {
	ClickedCallback = GenSlopeParts,
	ID = "Generate Slope Part",
	Tooltip = "For each selected wedge, generates a part at the center of it's slope facing the normal vector of the slope.",
	IconAssetID = "rbxassetid://73761969919675",
	LightIconAssetID = "rbxassetid://80151075507740"
}]]></ProtectedString>
						<string name="ScriptGuid">{EF142B23-FAE6-4E74-AA7B-0F241E14C468}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Main</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX2BF87D0A6A9F4A26A1CCB0360499E5C0">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Settings</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXEA6259AC7EBF4F7598E6698C8DA1C3B2">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.ToolsCommon)

local settingsKeys = require(script.Parent.SettingsKeys)

local settingsMenu: PluginMenu = nil
local oneClickEnableAction: PluginAction = nil
local oneClickDisableAction: PluginAction = nil

local function UpdateMenu()
	settingsMenu:Clear()
	if common:GetPluginSetting(settingsKeys.ONE_CLICK_ENABLED) ~= false then
		settingsMenu:AddAction(oneClickDisableAction)
	else
		settingsMenu:AddAction(oneClickEnableAction)
	end
end

local function ToggleOneClickEnabled()
	local currentState = common:GetPluginSetting(settingsKeys.ONE_CLICK_ENABLED)
	if currentState == nil then currentState = true end
	common:SetPluginSetting( settingsKeys.ONE_CLICK_ENABLED, not currentState )
	UpdateMenu()
	warn("Restart to apply setting (trust me I tried getting this to work without a restart)")
end

local function BuildMenu()
	oneClickEnableAction = common:CreatePluginAction(
		"OneClickEnable",
		"Enable One-Click Menu",
		"Toggles usage of the one-click menu for saving toolbar space.",
		"rbxassetid://125187645185104",
		"rbxassetid://80115599628137",
		false
	)
	oneClickEnableAction.Triggered:Connect(ToggleOneClickEnabled)
	
	oneClickDisableAction = common:CreatePluginAction(
		"OneClickDisable",
		"Disable One-Click Menu",
		"Toggles usage of the one-click menu for saving toolbar space.",
		"rbxassetid://125187645185104",
		"rbxassetid://80115599628137",
		false
	)
	oneClickDisableAction.Triggered:Connect(ToggleOneClickEnabled)
	
	settingsMenu = common:CreatePluginMenu("Settings", "Settings", "rbxassetid://87024861341187", "rbxassetid://127048252171392")
	UpdateMenu()
end

local function OpenWindow()
	settingsMenu:ShowAsync()
end

return {
	ID = "Settings",
	Tooltip = "Settings for SpongeAugments",
	IconAssetID = "rbxassetid://87024861341187",
	LightIconAssetID = "rbxassetid://127048252171392",
	ClickedCallback = OpenWindow,
	BuildMenu = BuildMenu
}]]></ProtectedString>
					<string name="ScriptGuid">{35A50E7E-2F47-4C7C-868B-9332127FA6DE}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAA6CBF867CE14C7482DCF6E060E6D29D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[return {
	ONE_CLICK_ENABLED = "OneClickEnabled"
}]]></ProtectedString>
					<string name="ScriptGuid">{4948C85F-7E17-4FC5-9058-4D864150BA5C}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">SettingsKeys</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX6516366BD9774BD189ACDB50EDDFFFDB">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">AttributeImporter</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX979C74707BB643D5BE351CC51219E4E3">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local common = require(script.Parent.Parent.ToolsCommon)
local attributeMan = require(script.Parent.AttributeMan)
local cinfoHandler = require(script.Parent.InfilClassInfo)

local function ValidBase(exact, archPath)
	if type(exact) == "string" and type(archPath) == "table" then return true end
	if exact == nil and type(archPath) == "string" then
		return false,
			"{vName} is invalid with reason : " .. archPath .. " : Instance will be skipped"
	elseif type(exact) == "string" and archPath == nil then
		return true,
			"{vName}'s class couldn't be inferred - will default to trying its name"
	else
		return false, 
			"Encountered unspecified error/bug in Class/Archetype deduction on {vName} - report this error message at your first convenience\n" ..
			`[DebugInfo] Exact: {exact}, ArchPath: {archPath}`
	end
end

local function HasPrivateAttrs(exact, archPath)
	local valid, warnMsg = ValidBase(exact, archPath)
	if not valid then return valid, warnMsg end
	valid = cinfoHandler.ClassHasPrivateAttrs(exact, archPath)
	return valid, (not valid) and `\{vName}'s class {exact} has no private attributes : Instance will be skipped`
end

local function AcceptsGlobalAttrs(exact, archPath)
	local valid, warnMsg = ValidBase(exact, archPath)
	if not valid then return valid, warnMsg end
	valid = cinfoHandler.ClassAcceptsGlobalAttrs(archPath)
	return valid, (not valid) and `\{vName}'s class {exact} does not import globals : Instance will be skipped`
end

local function ValidOfSelection(selection, includePrivate, includeGlobal)
	local validator = ((includePrivate == includeGlobal) and ValidBase) or (includePrivate and HasPrivateAttrs) or AcceptsGlobalAttrs
	
	local validSelection = {}
	for _, v in ipairs(selection) do 
		local exact, archPath = cinfoHandler.FindInstanceClass(v)
		local selectElemValid, warnMsg = validator(exact, archPath)
		if warnMsg then
			warnMsg = string.gsub(warnMsg, "{vName}", v.Name)
			warn(warnMsg)
		end
		
		if selectElemValid then
			validSelection[#validSelection+1] = v
		end
	end
	
	return validSelection
end

local function ImportAttributesForSelection(includePrivate, includeGlobal, deleting)
	local debugMission = common:LevelFolder()
	if debugMission == nil then warn("Couldn't find mission folder! Doing nothing") return end
	
	local selection = ValidOfSelection(game.Selection:Get(), includePrivate, includeGlobal)
	
	local recording = common:RecordChanges("Import Attributes For Selection")
	if not recording then return end
	
	-- Use pcall if sprix isn't in the session
	-- Just in case :3
	local runner
	if game.Players:FindFirstChild("Sprixitite") == nil then
		runner = function(fn)
			local success, errMsg = pcall(fn)
			if not success then warn(`Error importing attributes! Reason is as follows:\n{errMsg}`) end
			return success
		end
	else
		runner = function(fn) fn() return true end
	end
	
	local success = runner(function()
		for _, v in pairs(selection) do
			local instanceClass, classPath = cinfoHandler.FindInstanceClass(v)
			local attributeList = cinfoHandler.GetPrivateAttributes(instanceClass, classPath)
			if classPath == nil then attributeMan.ApplyAttributes(v, attributeList, deleting) continue end
			
			local classInfo = cinfoHandler.ClassInfoFromPath(classPath)
			attributeList = common:TableMerge(
				attributeList,
				includeGlobal and cinfoHandler.ClassAcceptsGlobalAttrs(classInfo) and cinfoHandler.GetGlobalAttributes() or {},
				true
			)
			
			attributeMan.ApplyAttributes(v, attributeList, deleting)
		end
	end)
	
	common:CommitChanges(recording, success and Enum.FinishRecordingOperation.Commit or Enum.FinishRecordingOperation.Cancel)
end

local function NonGlobalImport()
	ImportAttributesForSelection(true, false, false)
end

local function GlobalImport()
	ImportAttributesForSelection(false, true, false)
end

local function AllImport()
	ImportAttributesForSelection(true, true, false)
end

local function DeleteImported()
	ImportAttributesForSelection(true, true, true)
end

local function DeleteAll()
	local recording = common:RecordChanges("Import Attributes For Selection")
	if not recording then return end
	
	for _, v in pairs(common:GetSelection()) do
		for attrName, _ in pairs(v:GetAttributes()) do
			v:SetAttribute(attrName, nil)
		end
	end
	
	common:CommitChanges(recording)
end

local pluginMenu: PluginMenu? = nil

local function BuildMenu()
	local nonGlobalImport = common:CreatePluginAction(
		"AttributeImportNonGlobal", 
		"Import Non-Global Attributes",
		"Import all attributes specific to this Prop/StateComponent",
		"rbxassetid://73551897964793",
		"rbxassetid://132743443219803"
	)
	nonGlobalImport.Triggered:Connect(NonGlobalImport)
	
	local globalImport = common:CreatePluginAction(
		"AttributeImportGlobal", 
		"Import Global Attributes",
		"Import all attributes which aren't specific to a given Prop/StateComponent",
		"rbxassetid://109357542849581",
		"rbxassetid://133715331552259"
	)
	globalImport.Triggered:Connect(GlobalImport)
	
	local allImport = common:CreatePluginAction(
		"AttributeImportAll", 
		"Import All Attributes",
		"Import all global and relevant non-global attributes to this Prop/StateComponent",
		"rbxassetid://88889481728921",
		"rbxassetid://81720630505836"
	)
	allImport.Triggered:Connect(AllImport)
	
	local deleteImported = common:CreatePluginAction(
		"AttributeImportDelete",
		"Delete All Imported Attributes",
		"Delete all imported attributes from this Prop/StateComponent",
		"rbxassetid://120558084860550",
		"rbxassetid://94057149931568"
	)
	deleteImported.Triggered:Connect(DeleteImported)
	
	local deleteAll = common:CreatePluginAction(
		"AttributeImportDeleteAll",
		"Delete All Attributes",
		"Delete all attributes from this Instance",
		"rbxassetid://120558084860550",
		"rbxassetid://94057149931568"
	)
	deleteAll.Triggered:Connect(DeleteAll)
	
	pluginMenu = common:CreatePluginMenu("AttributeImporter", "Import Attributes", "rbxassetid://88889481728921", "rbxassetid://81720630505836")
	pluginMenu:AddAction(nonGlobalImport)
	pluginMenu:AddAction(globalImport)
	pluginMenu:AddAction(allImport)
	pluginMenu:AddAction(deleteImported)
	pluginMenu:AddAction(deleteAll)
end

local function OpenWindow()
	pluginMenu:ShowAsync()
end

return {
	ID = "Attribute Importer",
	Tooltip = "Automatically import all supported attributes to a prop",
	IconAssetID = "rbxassetid://88889481728921",
	LightIconAssetID = "rbxassetid://81720630505836",
	ClickedCallback = OpenWindow,
	BuildMenu = BuildMenu
}]]></ProtectedString>
					<string name="ScriptGuid">{EF17C8F4-4127-4D1F-890C-286169E6F9E2}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">Main</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXAEF7178287314CBFA859350F677B3D1A">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local AttributeType = require(script.Parent.NotMinePleaseDontSueMe.PropAttributeTypes)

local stateScriptInfo = {
	DebugLineVariable 	= { AttributeType.STRING, nil },
	DebugLogId			= { AttributeType.STRING, nil },
	DebugVariable		= { AttributeType.STRING, nil },
	Run 			= { AttributeType.STRING, "1" },
	ScriptSource 	= { AttributeType.STRING, nil },
	TriggerEvent	= { AttributeType.STRING, nil }
}

return {
	Bot = {
		AvoidInvestigation 			= { AttributeType.BOOL		, false 	},
		BodyguardTarget 			= { AttributeType.STRING	, nil 		},
		Behavior 					= { AttributeType.STRING	, "PatrolWalk" 	},
		CameraArea 					= { AttributeType.STRING	, nil 		},
		CharName 					= { AttributeType.STRING	, "Mr. Unlocalized String" },
		-- CharNameGroup 			= { AttributeType.INT		, 1 		}, Undocumented, dunno what to use for default
		CivilianHighlight 			= { AttributeType.BOOL		, false 	},
		Class 						= { AttributeType.STRING	, "Sec" 	},
		ClientTag 					= { AttributeType.STRING	, nil 		},
		CustomHairColor 			= { AttributeType.OPTIONAL_MISSION_COLOR, nil },
		CustomHairStyle				= { AttributeType.STRING	, nil 		},
		CustomPantsId				= { AttributeType.STRING	, nil 		},
		CustomShirtId				= { AttributeType.STRING	, nil 		},
		CustomSkinTone				= { AttributeType.OPTIONAL_MISSION_COLOR, nil },
		DespawnBlocked				= { AttributeType.STRING	, "0" 		},
		DespawnCondition			= { AttributeType.STRING	, nil 		},
		DetectionSpeed				= { AttributeType.NUMBER	, 1   		},
		EnforceClass				= { AttributeType.STRING	, "Alert1" 	},
		HeadTracking				= { AttributeType.BOOL		, false 	},
		HostageDifficulty			= { AttributeType.NUMBER	, 0 		},
		InterrogationNotification 	= { AttributeType.STRING	, nil 		},
		InterrogationVariable		= { AttributeType.STRING	, nil 		},
		Inv							= { AttributeType.STRING	, nil 		},
		MaxHealth					= { AttributeType.NUMBER	, 100 		},
		NeverIgnoreConversations	= { AttributeType.BOOL		, false 	},
		Nodes						= { AttributeType.STRING	, nil 		},
		NodesBreak					= { AttributeType.STRING	, nil 		},
		NoHostageDownInCombat		= { AttributeType.BOOL		, false 	},
		NoInvestigation				= { AttributeType.BOOL		, false 	},
		ObjectiveHighlight			= { AttributeType.BOOL		, false 	},
		OnlyHideWhenDead			= { AttributeType.BOOL		, false 	},
		Outfit						= { AttributeType.STRING	, "BasicSecurity" 	},
		PatrolCycleLength			= { AttributeType.NUMBER	, 1 		},
		PowerArea					= { AttributeType.STRING	, nil 		},
		Profile						= { AttributeType.STRING	, "BasicSecurity" 	},
		SearchArea					= { AttributeType.STRING	, nil 		},
		Seed						= { AttributeType.NUMBER	, 4736251 	},
		ServerTag					= { AttributeType.STRING	, nil 		},
		SpeakerId					= { AttributeType.STRING	, "Speaker.Unset" 	},
		Title						= { AttributeType.STRING	, "Name.Unset" 		},
		Weapon						= { AttributeType.STRING	, "K45" 	},
	},
	
	ConditionalGeometry = {
		IsSpawned = { AttributeType.EXPRESSION, "1" }
	},
	
	DoorGlass = {
		CanShatter = { AttributeType.BOOL, true },
	},
	
	DirectionalSpawnV2 = {
		BlockRange 			= { AttributeType.INT		,  2 	},
		EnabledCondition 	= { AttributeType.EXPRESSION, "1" 	}
	},
	
	FixedSpawn = {
		Enabled 		= { AttributeType.EXPRESSION, "1" 	},
		IgnoreProximity = { AttributeType.BOOL		, false },
		Range 			= { AttributeType.INT		, 3 	},
		SpawnTag 		= { AttributeType.STRING	, nil 	}
	},
	
	Glass = {
		StateValue = { AttributeType.EXPRESSION, nil 	},
		NoAutoSize = { AttributeType.BOOL	   , false 	}, -- No idea what this actually does, all I know is the templates use it
	},
	
	Link = {
		Move = 	{ AttributeType.EXPRESSION, "1" },
		Open = 	{ AttributeType.EXPRESSION, "1" },
		Path = 	{ AttributeType.EXPRESSION, "1" },
		Sound = { AttributeType.NUMBER	  ,  1  },
	},

	StateScript = stateScriptInfo,
	StateScriptPart = stateScriptInfo,
	
	Motor = {
		Link			= { AttributeType.STRING, 	nil 	},
		Offset			= { AttributeType.CFRAME, 	nil 	},
		Rotation 		= { AttributeType.VECTOR3, 	nil 	},
		AnimType		= { AttributeType.INT	, 	nil 	},
		AnimTime		= { AttributeType.NUMBER, 	nil 	},
		ClampMax		= { AttributeType.NUMBER, 	0 		},
		ClampMin		= { AttributeType.NUMBER, 	1 		},
		ClampLoop		= { AttributeType.BOOL	, 	false 	},
	},
	
	CustomPropPart = {
		PropDamage 		= { AttributeType.BOOL, 	true 		},
		CollisionGroup	= { AttributeType.STRING, 	"Default"	}
	},
	
	CustomItem = {
		Class 			= { AttributeType.STRING, "None" 			},
		DescKey 		= { AttributeType.STRING, "ItemDesc.Unset"	},
		InvSizeX		= { AttributeType.INT,	  1 				},
		InvSizeY		= { AttributeType.INT,	  1 				},
		IsOffhand		= { AttributeType.BOOL,	  false 			},
		IsOffhandOnly	= { AttributeType.BOOL,	  false 			},
		NameKey			= { AttributeType.STRING, "Item.Unset" 		},
		Volume			= { AttributeType.INT,	  4 				},
		Weight			= { AttributeType.INT,	  0 				}
	},
	
	CombatFlowNode = {
		BlockedLinks	= { AttributeType.STRING, "{}" },
		FilteredLinks	= { AttributeType.STRING, "[]" },
		Id				= { AttributeType.STRING, function(n) return n.Name end },
		LinkedIds		= { AttributeType.STRING, "[]" },
	}
}]]></ProtectedString>
					<string name="ScriptGuid">{A13780BC-4015-49C6-82E2-2B28498EC609}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">PropListExtensions</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX94C3C362132C451BA2DB38794C7F480D">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local httpService = game:GetService("HttpService")

local common = require(script.Parent.Parent.ToolsCommon)
local plugin = require(script.Parent.Parent.PluginSingleton):Underlying()

local InfilClassInfo = {}

local APIConsumer = require(script.Parent.APIConsumer)
local internalAttributesMap = require(script.Parent.NotMinePleaseDontSueMe.AttributesMap)
local attrMan = require("./AttributeMan")

local searchInfoValidator = require(script.Parent.SearchInfo.Validator)
local builtinSearchInfo = require(script.Parent.SearchInfo.Builtin)
local foreignSeachInfo = {}

InfilClassInfo.BuiltinSearchInfo = builtinSearchInfo
InfilClassInfo.ForeignSearchInfo = foreignSeachInfo

local infilEngineAttributes = {
	Global = require(script.Parent.NotMinePleaseDontSueMe.GlobalAttributes),
	Extensions = require(script.Parent.PropListExtensions),
	PluginExtensions = {}
}

local function GetUserExtensions()
	local userExtensionsScript = game.ReplicatedStorage:FindFirstChild("AttributesMapExtensions")
	if not userExtensionsScript then return {} end
	if not userExtensionsScript:IsA("ModuleScript") then warn(`AttributesMapExtensions is of invalid class {userExtensionsScript.ClassName}!`) return {} end
	local success, extensions = pcall(function() return require(userExtensionsScript) end)
	if not success then warn(`AttributesMapExtensions failed to execute, failed with: `, extensions) return {} end
	return extensions
end

local function onAPILoaded(api: APIConsumer.APIReference, state)
	state.APIHooks = state.APIHooks or {}
	state.APIExtensions = state.APIExtensions or {}
	state.APIExtensions[1] = api.AddAPIExtension(
		"AttributeImporter",
		"Sprix",
		{
			AddAbstractionImporter = function(abstractionName, searchInfo, importCallback)
				if type(searchInfo) ~= "table" then return nil end
				if type(importCallback) ~= "function" then return nil end
				if type(abstractionName) ~= "string" then return nil end
				
				local infoValid = searchInfoValidator.EntryIsValid(searchInfo, abstractionName)
				if not infoValid then return nil end
				
				local token = httpService:GenerateGUID(false)
				
				searchInfo.IsAbstraction = true
				searchInfo.AbstractionName = abstractionName
				
				InfilClassInfo.ForeignSearchInfo[abstractionName] = searchInfo
				infilEngineAttributes.PluginExtensions[token] = {
					Name = abstractionName,
					Callback = importCallback
				}
				return token
			end,
			RemoveAbstractionImporter = function(token)
				local abstractionName = infilEngineAttributes.PluginExtensions[token].Name 
				InfilClassInfo.ForeignSearchInfo[abstractionName] = nil
				infilEngineAttributes.PluginExtensions[token] = nil
			end,
		}
	)
	
end

local function onAPIUnloaded(api: APIConsumer.APIReference, state)
	for _, token in ipairs(state.APIHooks) do
		api.RemoveHook(token)
	end
	
	for _, extensionToken in ipairs(state.APIExtensions) do
		api.RemoveAPIExtension(extensionToken)
	end
end

task.spawn(function()
	APIConsumer.DoAPILoop(plugin, "SpongeZoneTools-AttributeImporter", onAPILoaded, onAPIUnloaded, {})
end)

setmetatable(
	infilEngineAttributes,
	{
		__index = function(tbl, k)
			if k == "Private" then
				local success, api = APIConsumer.TryGetAPI()
				if not success then return internalAttributesMap end
				return api.GetAttributesMap()
			elseif k == "UserExtensions" then
				return GetUserExtensions()
			end
		end,
	}
)

local function GetExactClass(instance, arch)
	local exactClass = nil
	local failReason = nil
	if arch.TypeIsName then
		exactClass = instance.Name
	elseif arch.TypeIsAttribute then
		exactClass = instance:GetAttribute(arch.TypeIsAttribute)
		failReason = (type(exactClass) ~= "string") and arch.TypeIsAttribute .. " attribute is of non-string datatype on " .. tostring(instance.Parent) .. '.' .. instance.Name
	elseif arch.TypeIsParentName then
		exactClass = instance.Parent.Name
	else
		exactClass = arch.Name
	end
	return exactClass, failReason
end

local function FindExactClassRecurse(instance: Instance, knownClass: builtinSearchInfo.ClassSearchInfo, recurse_tpath: {string}?)
	recurse_tpath = recurse_tpath or {}
	local exactClass, failReason = GetExactClass(instance, knownClass)
	if exactClass == nil then
		return nil, failReason
	end
	
	recurse_tpath[#recurse_tpath+1] = knownClass.Name
	if knownClass.SubTypes == nil then
		return exactClass, recurse_tpath
	end
	
	local defaultSubType = nil
	for k, subType in pairs(knownClass.SubTypes) do
		if subType.IsDefault then defaultSubType = subType continue end
		local subTypeClass = GetExactClass(instance, subType)
		if subType.Name ~= subTypeClass then continue end
		return FindExactClassRecurse(instance, subType, recurse_tpath)
	end
	
	if defaultSubType then return FindExactClassRecurse(instance, defaultSubType, recurse_tpath) end
	
	return exactClass, recurse_tpath
end

local function folderPathCheck(instance, folderPath, descendant)
	if type(folderPath) ~= "table" then folderPath = { folderPath } end
	if type(folderPath[1]) ~= "table" then folderPath = { folderPath } end
	local checkPassed = false
	for _, validPath in ipairs(folderPath) do
		if validPath[1] == "@LevelRoot" then
			checkPassed = instance.Parent == common:LevelFolder()
		else
			checkPassed = common:AncestryCheck(instance, validPath, descendant)
		end
		if checkPassed then break end
	end
	return checkPassed
end

function InfilClassInfo.FindInstanceClass(instance)
	for _, v in pairs(InfilClassInfo.BuiltinSearchInfo) do	
		if not folderPathCheck(instance, v.FolderPath, v.FolderRelation == "descendant") then continue end
		
		if v.ValidClasses ~= nil and not common:InstanceIsAny(instance, v.ValidClasses) then 
			warn(`Instance {instance.Name} is not a valid {v.Name}! Skipping`) 
			return nil 
		end
		
		return FindExactClassRecurse(instance, v)
	end
	
	for _, v in pairs(InfilClassInfo.ForeignSearchInfo) do
		if not folderPathCheck(instance, v.FolderPath, v.FolderRelation == "descendant") then continue end

		if v.ValidClasses ~= nil and not common:InstanceIsAny(instance, v.ValidClasses) then 
			warn(`Instance {instance.Name} is not a valid {v.Name}! Skipping`) 
			return nil 
		end

		return FindExactClassRecurse(instance, v)
	end
	
	warn(`{instance.Parent.Name}.{instance.Name} is of unknown class!`)
	return instance.Name, nil
end

function InfilClassInfo.GetPrivateAttributes(className, classPath)
	local classSearchInfo = InfilClassInfo.ClassInfoFromPath(classPath)
	local privateAttrList = {}
	common:TableMerge(privateAttrList, infilEngineAttributes.Extensions[className])
	common:TableMerge(privateAttrList, infilEngineAttributes.Private[className])
	common:TableMerge(privateAttrList, infilEngineAttributes.UserExtensions[className])
	
	if type(classSearchInfo) == "table" and classSearchInfo.IsAbstraction then
		for _, abstraction in pairs(infilEngineAttributes.PluginExtensions) do
			if abstraction.Name ~= classSearchInfo.AbstractionName then continue end
			local abstractionAttrs = {}
			local success, attrs = pcall(abstraction.Callback, className)
			if not success then
				warn(`Attribute Importer : {abstraction.Name} Callback : Failed with {attrs} : Will Ignore`)
				continue
			end
			for k, attr in pairs(attrs) do
				abstractionAttrs[k] = { attrMan.AttributeTypeFromNativeType(attr[1]), attr[2] }
			end
			common:TableMerge(privateAttrList, abstractionAttrs)
		end
	end

	return privateAttrList
end

function InfilClassInfo.GetGlobalAttributes() return infilEngineAttributes.Global end

local function tostringClassPath(classPath, classPathStr)
	if #classPath < 1 then return classPathStr end
	classPathStr = classPathStr or ""
	classPathStr = `{classPathStr}/{classPath[1]}`
	return tostringClassPath(common:TableSlice(classPath, 2, #classPath), classPathStr)
end

local function traverseClassPath(classPath, classSrc: {builtinSearchInfo.ClassSearchInfo})
	if classPath == nil then return nil end
	if classPath[1] == nil then return nil end
	local nextInPath = classSrc[classPath[1]] 
	if nextInPath == nil then return nil end
	if #classPath < 2 then
		return nextInPath
	else
		return traverseClassPath(common:TableSlice(classPath, 2, #classPath), nextInPath.SubTypes)
	end
end

function InfilClassInfo.ClassInfoFromPath(classPath)
	return traverseClassPath(classPath, InfilClassInfo.BuiltinSearchInfo) 
		or traverseClassPath(classPath, InfilClassInfo.ForeignSearchInfo)
end

function InfilClassInfo.ClassHasPrivateAttrs(exactClass, classPath)
	local classSearchInfo = InfilClassInfo.ClassInfoFromPath(classPath)
	if type(classSearchInfo) == "table" and classSearchInfo.IsAbstraction then
		for _, pluginExtension in pairs(infilEngineAttributes.PluginExtensions) do
			if pluginExtension.Name == classSearchInfo.AbstractionName then return true end
		end
	end
	return infilEngineAttributes.Private[exactClass] ~= nil 
		or infilEngineAttributes.Extensions[exactClass] ~= nil
		or infilEngineAttributes.UserExtensions[exactClass] ~= nil
end

function InfilClassInfo.ClassAcceptsGlobalAttrs(class: builtinSearchInfo.ClassSearchInfo)
	return class.ImportsGlobals
end

return InfilClassInfo]]></ProtectedString>
					<string name="ScriptGuid">{C41F5D79-94D5-4CD3-AA9C-67754D8BE978}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">InfilClassInfo</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXFBE6346529F24F539D508F1778E98C38">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[local attributeType = require(script.Parent.NotMinePleaseDontSueMe.PropAttributeTypes)

local AttributeMan = {}

local attributeTypeDefaults = {
	[attributeType.NUMBER					] = 0,
	[attributeType.INT						] = 0,
	[attributeType.OPTIONAL_INT				] = 0,

	[attributeType.EXPRESSION				] = "",
	[attributeType.STATE_VALUE				] = "",
	[attributeType.STRING					] = "",
	[attributeType.OPTIONAL_MATERIAL		] = "Neon",

	[attributeType.NETWORK_ID				] = 0,
	[attributeType.NETWORK_ID_STRING		] = "",

	[attributeType.BOOL						] = false,
	[attributeType.OPTIONAL_BOOL			] = false,

	[attributeType.OPTIONAL_MISSION_COLOR	] = Color3.new(0,1,0),
	[attributeType.VECTOR3					] = Vector3.new(),

	[attributeType.CFRAME					] = CFrame.new(),
}

local attributeTypeNativeTypes = {}
for k, v in pairs(attributeTypeDefaults) do attributeTypeNativeTypes[k] = typeof(v) end

local nativeTypesToAttributeTypes = {}
for k, v in pairs(attributeTypeNativeTypes) do
	if nativeTypesToAttributeTypes[v] ~= nil then continue end
	nativeTypesToAttributeTypes[v] = k
end

function AttributeMan.AttributeTypeFromNativeType(nativeType)
	return nativeTypesToAttributeTypes[nativeType]
end

function AttributeMan.ValueOrDefault(attrDetails)
	if attrDetails[2] == nil or typeof(attrDetails[2]) ~= attributeTypeNativeTypes[attrDetails[1]] then
		-- Use default from above table if AttributesMap provides no default
		-- Or if default is of wrong type
		return attributeTypeDefaults[attrDetails[1]]
	else
		return attrDetails[2]
	end
end

function AttributeMan.ApplyAttributes(to, attrs, deleting)
	for attrName, attrDetails in pairs(attrs) do
		if deleting then to:SetAttribute(attrName, nil) continue end
		if to:GetAttribute(attrName) ~= nil then continue end
		
		local newAttrVal = AttributeMan.ValueOrDefault(attrDetails)
		if type(attrDetails[2]) == "function" then
			local success, attrVal = pcall(attrDetails[2], to)
			if success and typeof(attrVal) == typeof(newAttrVal) then
				newAttrVal = attrVal
			elseif success then
				warn(`Attribute function {attrName} returned value of type {typeof(attrVal)}, expected {typeof(newAttrVal)} - will use safe default`)
			else
				warn(`Attribute function {attrName} failed with reason: {attrVal}`)
			end
		end
		to:SetAttribute(attrName, newAttrVal)
	end
end

return AttributeMan
]]></ProtectedString>
					<string name="ScriptGuid">{65E3F41E-4C03-47DA-B6BA-B18BBE32298D}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">AttributeMan</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX20363D7726F348A980D583C6601405DA">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
					<string name="ScriptGuid">{1CDF5597-3431-4C6D-B0B5-377FD99D4058}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">APIConsumer</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXA448BFA202054BDB8F1EC55BD5B37AC4">
				<Properties>
					<Content name="LinkedSource"><null></null></Content>
					<ProtectedString name="Source"><![CDATA[--[[
	GLUt // GoodLuaUtilities // Lua5.1 utilities module
	
	 Sprixitite, 2025
]]

local GLUt = {}

local GLUtCfg = {
	print = print,
	warn  = function(...) print("WARNING", ...) end,
	error = error,
	type  = type
}

local patternSpecChars = { '(', ')', '.', '%', '+', '-', '*', '?', '[', ']', '^', '$' }

GLUt.severity = {
	SILENT = 0,
	LOG = 1,
	WARN = 2,
	ERR = 3,
	ERROR = 3
}

local function severity_warn(sev, ...)
	if sev == GLUt.severity.SILENT then return end
	local warn_fn
	if sev == GLUt.severity.LOG then
		warn_fn = GLUtCfg.print
	elseif sev == GLUt.severity.WARN then
		warn_fn = GLUtCfg.warn
	else
		warn_fn = GLUtCfg.error
	end
	warn_fn(...)
end

function GLUt.configure(tbl)
	for k, v in pairs(tbl) do
		if GLUtCfg[k] ~= nil then
			GLUtCfg[k] = v
		else
			GLUtCfg.warn("Attempt to set invalid GLUtCfg Key \"" .. tostring(k) .. "\"")
		end
	end
end

function GLUt.custom_iter(tbl, keys)
	local i = 0
	return function()
		i = i + 1
		local requested = {}
		local iTbl = tbl[i]
		if iTbl == nil then return nil end
		for _, k in ipairs(keys) do
			requested[#requested+1] = iTbl[k]
		end 
		return i, unpack(requested)
	end
end

function GLUt.custom_iter_template(...)
	local varargs = { ... }
	return function(tbl) return GLUt.custom_iter(tbl, varargs) end
end

function GLUt.default(arg, default)
	return (arg == nil) and default or arg
end

function GLUt.default_exec(arg, fn)
	return (arg == nil) and fn() or arg
end

function GLUt.default_bounds(arg, default, min, max)
	if arg == nil then return default end
	if arg < min then return default end
	if max < arg then return default end
	return arg
end

function GLUt.default_typed(arg, default, argName, funcName)
	local argType = GLUtCfg.type(arg)
	local defaultType = GLUtCfg.type(default)
	if argType == defaultType then return arg end
	if argType == "nil" then return default end
	GLUt.type_warn(argName, funcName, defaultType, argType)
	return default
end

function GLUt.type_warn(argName, funcName, expected, got, severity)
	if argName == nil or expected == got then return end
	if type(severity) == "boolean" then
		severity = severity and GLUt.severity.ERROR or GLUt.severity.WARN 
	end
	severity = GLUt.default_bounds(severity, GLUt.severity.ERROR, GLUt.severity.SILENT, GLUt.severity.ERROR)

	local warnStart = GLUt.type_is(funcName, "string") and (funcName .. ": expected arg \"") or "Expected arg \""
	severity_warn(severity, warnStart .. argName .. "\" of type \"" .. expected .. "\" got type \"" .. got .. "\"!")
	severity_warn(severity, "Traceback: " .. debug.traceback())
end

function GLUt.type_check(arg, expected, argName, funcName, severity)
	local argType = GLUtCfg.type(arg)

	expected = string.gsub(expected, '?', "|nil")
	for _, validType in pairs(GLUt.str_split(expected, '|')) do
		if validType == argType then return true end
	end

	GLUt.type_warn(argName, funcName, expected, argType, severity)

	return false
end

function GLUt.type_is(a1, t)
	return GLUtCfg.type(a1) == t
end

function GLUt.type_eq(a1, a2)
	return GLUtCfg.type(a1) == GLUtCfg.type(a2)
end

function GLUt.vararg_capture(...)
	local n = select('#', ...)
	return n, { ... }
end

function GLUt.vararg_iter(...)
	local n, t = GLUt.vararg_capture(...)
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

function GLUt.str_split(str, separator)
	str = str .. separator
	separator = GLUt.str_escape_pattern(separator)

	local substrs = {}
	for substr in string.gmatch(str, "(.-)" .. separator) do
		substrs[#substrs+1] = substr
	end
	return substrs
end

function GLUt.str_has_match(str, pattern)
	return string.match(str, pattern) ~= nil
end

function GLUt.str_escape_pattern(str)
	local escaped = str
	for _, specChar in ipairs(patternSpecChars) do
		local escapedSpec = '%' .. specChar
		escaped = string.gsub(escaped, escapedSpec, (specChar == '%') and "%%" or '%' .. escapedSpec)
	end
	return escaped
end

function GLUt.str_double_substr(str, substr)
	local safe = GLUt.str_escape_pattern(substr)
	return string.gsub(str, safe, safe .. safe)
end

function GLUt.str_isempty(str)
	return string.match(str, "^%s$") ~= nil
end

function GLUt.str_chariter(str)
	local n = #str
	local i = 0
	return function()
		i = i + 1
		if i <= n then return GLUt.str_getchar(str, i) end
	end
end

function GLUt.str_trim(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return GLUt.str_trimend(GLUt.str_trimstart(str, pattern), pattern)
end

function GLUt.str_trimstart(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return string.gsub(str, '^' .. pattern, "")
end

function GLUt.str_trimend(str, pattern)
	pattern = GLUt.default(pattern, "%s")
	return string.gsub(str, pattern .. '$', "")
end

function GLUt.str_getchar(str, i)
	return string.sub(str, i, i)
end

local unidentified = -1
function GLUt.str_runlua(source, fenv, chunkName)
	chunkName = GLUt.default_exec(chunkName, function()
		unidentified = unidentified + 1
		return "loadstring#" .. tostring(unidentified) 
	end)

	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	strFun = setfenv(strFun, fenv)

	return pcall(function()
		return GLUt.vararg_capture(strFun())
	end)
end

function GLUt.str_runlua_unsafe(source, chunkName)
	local strFun, failReason = loadstring(source, chunkName)
	if GLUtCfg.type(strFun) ~= "function" then
		return false, "Loadstring : " .. chunkName .. " : Evaluation failed : " .. failReason
	end

	return pcall(function()
		return GLUt.vararg_capture()
	end)
end

function GLUt.kvp_tostring(k, v)
	return tostring(k) .. " = " .. tostring(v)
end

function GLUt.tbl_tryindex(tbl, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(k)]
	end

	return true, indexing
end

function GLUt.tbl_deepget(tbl, create_missing, ...)
	local indexing = tbl
	for i, k, n in GLUt.vararg_iter(...) do
		k = tostring(k)

		if indexing[k] == nil and create_missing then
			indexing[k] = {}
		end

		indexing = indexing[k]
		if GLUtCfg.type(indexing) ~= "table" and not (i == n) then
			return false, indexing, k
		end
	end

	return true, indexing
end

function GLUt.tbl_getkeys(tbl)
	local keys = {}
	for k, _ in pairs(tbl) do keys[#keys+1] = k end
	return keys
end

function GLUt.tbl_clone(tbl, shallow)
	shallow = GLUt.default(shallow, false)

	local cloned = {}
	for k, v in pairs(tbl) do
		if GLUtCfg.type(v) == "table" and not shallow then
			cloned[k] = GLUt.tbl_clone(v, shallow)
		else
			cloned[k] = v
		end
	end
	return cloned
end

function GLUt.tbl_merge(tbl1, tbl2, priority)
	priority = GLUt.default(priority, 1)
	local secondPriority = priority == 2
	local merged = {}
	for k, v in pairs(tbl1) do
		merged[k] = v
	end
	for k, v in pairs(tbl2) do
		local existing = merged[k]
		if GLUtCfg.type(existing) == "table" then
			merged[k] = GLUt.tbl_merge(existing, v, priority)
		elseif existing ~= nil and secondPriority then
			merged[k] = v
		elseif merged[k] == nil then
			merged[k] = v
		end
	end
	return merged
end

function GLUt.tbl_findsize(tbl)
	local i = 0
	for _, _ in pairs(tbl) do i = i + 1 end
	return i
end

local function tbl_tostring(tblName, tbl, levels, level)
	local str = tblName .. " = {"
	local indent = string.rep("  ", level)
	local n = GLUt.tbl_findsize(tbl)
	local i = 0
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. '\n' .. indent
		if GLUtCfg.type(v) == "table" and levels > level then
			str = str .. tbl_tostring(k, v, levels, level+1)
		else
			str = str .. GLUt.kvp_tostring(k, v)
		end
		if i < n then str = str .. ',' end
	end
	return str
end

function GLUt.tbl_tostring(tbl, levels, tblName)
	GLUt.default(tblName, tostring(tbl))
	return tbl_tostring(tblName, tbl, levels, 1)
end

function GLUt.tbl_any(tbl, f)
	local anySucceed = nil
	for k, v in pairs(tbl) do
		anySucceed = GLUt.default(anySucceed, false) or f(k, v)
		if anySucceed then break end
	end
	return anySucceed
end

function GLUt.tbl_all(tbl, f)
	local allSucceed = nil
	for k, v in pairs(tbl) do
		allSucceed = GLUt.default(allSucceed, true) and f(k, v)
		if not allSucceed then break end
	end
	return allSucceed
end

function GLUt.tbl_is_arr(tbl)
	local isArr = true
	for k, v in pairs(tbl) do
		isArr = isArr and GLUtCfg.type(k) == "number"
		if not isArr then break end
	end
	return isArr
end

local function tbl_arginfo(argType, name, index, expectedType)
	local typeStr = GLUt.type_is(expectedType, "string") and (" <T:" .. expectedType .. ">") or ""
	return argType .. " \"" .. name .. "\" (#" .. tostring(index) .. ")" .. typeStr 
end

local function tbl_argextract(fname, t, arglayout)
	local index = arglayout[1]
	local name = arglayout[2]
	local expectedType = arglayout[3]
	local canName = arglayout[4]
	local default = arglayout.Default or arglayout.default
	local vital = GLUt.default(arglayout.Vital or arglayout.vital, false)

	local tVal = t[index]
	if canName and tVal ~= nil then
		if t[name] ~= nil then
			return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo("Arg", name, index, expectedType) .. " passed both by name and index!")
		end
	elseif canName then
		tVal = t[name]
	end

	if tVal == nil and default ~= nil then
		tVal = default
	end

	if tVal == nil and expectedType == false then
		return nil
	elseif tVal == nil and not GLUt.str_has_match(expectedType, "%?") then
		local argType = vital and "Vital Arg" or "Arg"
		return GLUtCfg.error(fname .. "@tblcall : " .. tbl_arginfo(argType, name, index, expectedType) .. " not passed!")
	end

	if expectedType == false then return tVal end
	if not GLUt.type_check(tVal, expectedType, name, fname, true) then return nil end
	return tVal
end

function GLUt.fun_tblcallable(fname, f, ...)
	local n, callingConvention = GLUt.vararg_capture(...)
	return function(tbl)
		for k, v in pairs(tbl) do
			local isValid = false
			for i=1, n do
				if isValid then break end
				local validArg = callingConvention[i]
				isValid = (k == i) or (k == validArg[2])
			end
			if not isValid then
				GLUtCfg.error("Received unexpected argument \"" .. tostring(k) .. "\" of type \"" .. GLUtCfg.type(v) .. "\"!")
			end
		end
		local args = {}
		for i=1, n do
			local argLayout = callingConvention[i]
			args[i] = tbl_argextract(fname, tbl, argLayout)
		end
		return f(unpack(args, 1, n))
	end
end

return GLUt]]></ProtectedString>
					<string name="ScriptGuid">{025F4BF9-9A85-4687-9292-4FCE12E05C7F}</string>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">GLUt</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX2BEC69E6A5514C479C0E9D59D27A3291">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">NotMinePleaseDontSueMe</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3345A5D7874A4F5280DCD21055403028">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local PropAttributeTypes = require(script.Parent.PropAttributeTypes)
return { 
	GlobalVariables 	= { PropAttributeTypes.OPTIONAL_BOOL, 			nil },
	OnProp 				= { PropAttributeTypes.OPTIONAL_BOOL, 			nil },
	ScriptMove 			= { PropAttributeTypes.OPTIONAL_BOOL, 			nil },
	Index 				= { PropAttributeTypes.OPTIONAL_INT, 			nil },
	CanShatter 			= { PropAttributeTypes.OPTIONAL_BOOL, 			nil },
	Tag 				= { PropAttributeTypes.STRING, 					nil },
	TagOffset 			= { PropAttributeTypes.VECTOR3, 				nil },
	StaticTag 			= { PropAttributeTypes.STRING, 					nil },
	HasTopBarrier 		= { PropAttributeTypes.OPTIONAL_BOOL, 			nil },
	Indestructible 		= { PropAttributeTypes.EXPRESSION, 				nil },
	NoPropDamage 		= { PropAttributeTypes.EXPRESSION, 				nil },
	IsSpawned 			= { PropAttributeTypes.EXPRESSION, 				nil },
	Color0 				= { PropAttributeTypes.OPTIONAL_MISSION_COLOR, 	nil },
	Color1 				= { PropAttributeTypes.OPTIONAL_MISSION_COLOR, 	nil },
	Color2 				= { PropAttributeTypes.OPTIONAL_MISSION_COLOR, 	nil },
	Color3 				= { PropAttributeTypes.OPTIONAL_MISSION_COLOR, 	nil },
	Color4 				= { PropAttributeTypes.OPTIONAL_MISSION_COLOR, 	nil },
	Color5 				= { PropAttributeTypes.OPTIONAL_MISSION_COLOR, 	nil },
	Material0 			= { PropAttributeTypes.OPTIONAL_MATERIAL, 		nil },
	Material1 			= { PropAttributeTypes.OPTIONAL_MATERIAL, 		nil },
	Material2 			= { PropAttributeTypes.OPTIONAL_MATERIAL, 		nil },
	Material3 			= { PropAttributeTypes.OPTIONAL_MATERIAL, 		nil },
	Material4 			= { PropAttributeTypes.OPTIONAL_MATERIAL, 		nil },
	Material5 			= { PropAttributeTypes.OPTIONAL_MATERIAL, 		nil },
	Type 				= { PropAttributeTypes.STRING, 					nil },
	AltProp 			= { PropAttributeTypes.STRING, 					nil },
	AltPropModel 		= { PropAttributeTypes.STRING, 					nil },
	FadeOutCondition 	= { PropAttributeTypes.STRING, 					nil },
	CollisionGroup 		= { PropAttributeTypes.STRING, 					nil },
	TagButton 			= { PropAttributeTypes.EXPRESSION, 				nil }
}]]></ProtectedString>
						<string name="ScriptGuid">{C82FF03D-384C-4A72-8725-96A2B84E5EC8}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">GlobalAttributes</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX42929C9EDA0B4D39B4074DB3214F4106">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local PropAttributeTypes

PropAttributeTypes = {
	NUMBER = 1,
	INT = 2,
	EXPRESSION = 3,
	STATE_VALUE = 4,
	STRING = 5,
	NETWORK_ID = 6,
	NETWORK_ID_STRING = 7,
	OPTIONAL_BOOL = 8,
	OPTIONAL_MISSION_COLOR = 9,
	OPTIONAL_MATERIAL = 10,
	VECTOR3 = 11,
	OPTIONAL_INT = 12,
	BOOL = 13,
	CFRAME = 14,
}

return PropAttributeTypes]]></ProtectedString>
						<string name="ScriptGuid">{F6823BC2-884C-4658-9542-7A991DD1A476}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">PropAttributeTypes</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX5CC556976615402F8806CF2BEFBEEB30">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[-- NOTE: Do not edit this file manually. Use PropCompiler.py.
AttributeType = require(script.Parent.PropAttributeTypes)
return {
	AccessPoint = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	AmmoBox = {
	},
	BadgeReader = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CustomBadges = {AttributeType.STRING, ""},
		UseITBadge = {AttributeType.BOOL, false},
		UseLeadSecurityBadge = {AttributeType.BOOL, false},
		UseSecurityBadge = {AttributeType.BOOL, false},
	},
	BarredWindow = {
		GlassMaterial = {AttributeType.STRING, "SmoothPlastic"},
		GlassTransparency = {AttributeType.NUMBER, 0.8},
		HorizontalSpacing = {AttributeType.NUMBER, 2},
		VerticalSpacing = {AttributeType.NUMBER, 2},
	},
	BoxStack2 = {
	},
	CandlePlate = {
	},
	CardboardBox = {
	},
	CardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		LightLevel = {AttributeType.INT, 1},
		Blocked = {AttributeType.EXPRESSION, ""},
		LockdownReason = {AttributeType.EXPRESSION, nil},
	},
	CeilingAccessPoint = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	CircuitBoxLarge = {
		ClientExaminedVariable = {AttributeType.STATE_VALUE, ""},
		ExaminedVariable = {AttributeType.STATE_VALUE, ""},
		RewiredVariable = {AttributeType.STATE_VALUE, ""},
	},
	ClientExplosionEffect = {
		Active = {AttributeType.EXPRESSION, ""},
		Intensity = {AttributeType.NUMBER, 1},
	},
	ClimbablePipe = {
	},
	ClothingRack = {
		Active = {AttributeType.EXPRESSION, ""},
		Disguise = {AttributeType.STRING, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		ClientUsedVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, "0"},
	},
	CodeCardReader = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		ValidCards = {AttributeType.STRING, ""},
		CodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		WrongCodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeSeed = {AttributeType.INT, 1},
		PromptText = {AttributeType.STRING, ""},
		MinimumCard = {AttributeType.STRING, ""},
		ReaderEnabled = {AttributeType.EXPRESSION, "1"},
		AltPromptActive = {AttributeType.EXPRESSION, ""},
		AltPromptSwitchTime = {AttributeType.NUMBER, 1},
	},
	CodeKeypad = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		PromptText = {AttributeType.STRING, ""},
		WrongCodeVariable = {AttributeType.STATE_VALUE, ""},
		ReadoutText = {AttributeType.EXPRESSION, ""},
		RewireTime = {AttributeType.NUMBER, 12},
		PromptSubtitle = {AttributeType.STRING, ""},
		KeypadEnabled = {AttributeType.EXPRESSION, "1"},
		NoiseEnabled = {AttributeType.EXPRESSION, ""},
		CodeVariable = {AttributeType.STATE_VALUE, ""},
		CodeSeed = {AttributeType.INT, 1},
	},
	CombatCuttableFence = {
	},
	CustomMissionLoadPoint = {
	},
	DecorativeDepositBox1 = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativeDepositBox2 = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativeDepositBox3 = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativeDepositBoxHalf = {
		IncludeSidePart = {AttributeType.BOOL, true},
	},
	DecorativePipe = {
		RingSpace = {AttributeType.NUMBER, 8},
		Corner = {AttributeType.BOOL, false},
		BendTop = {AttributeType.BOOL, false},
	},
	DecorativeVent = {
		BendBottom = {AttributeType.INT, 0},
		BendTop = {AttributeType.INT, 0},
		RingSpace = {AttributeType.NUMBER, 8},
		RingDepth = {AttributeType.NUMBER, 0},
	},
	DepositBox1 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DepositBox2 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DepositBox3 = {
		TiltItem = {AttributeType.NUMBER, 0},
		RotateItem = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeSidePart = {AttributeType.BOOL, true},
		BoxNumber = {AttributeType.INT, 1},
	},
	DeskPhoneCallable = {
		CallAcceptedVariable = {AttributeType.STATE_VALUE, ""},
		CallIgnoredVariable = {AttributeType.STATE_VALUE, ""},
		IsCalling = {AttributeType.EXPRESSION, ""},
		CallTime = {AttributeType.INT, 15},
	},
	DeskSafe = {
		ItemTagString = {AttributeType.STRING, ""},
		Item = {AttributeType.STRING, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
	},
	DisguiseTrigger = {
		Active = {AttributeType.EXPRESSION, ""},
		Disguise = {AttributeType.STRING, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		ClientUsedVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, "0"},
	},
	DomeCamera = {
		AngleMax = {AttributeType.STRING, "0"},
		AngleMin = {AttributeType.STRING, "0"},
		Exterior = {AttributeType.BOOL, true},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		NetworkDestination = {AttributeType.NETWORK_ID_STRING, ""},
		CamSet = {AttributeType.STRING, ""},
		CameraArea = {AttributeType.STRING, ""},
		AngleDown = {AttributeType.NUMBER, 0},
		Wireless = {AttributeType.BOOL, true},
		CamNumber = {AttributeType.INT, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		LocationKey = {AttributeType.STRING, ""},
		MapFloorOffset = {AttributeType.INT, 0},
		WarpPoint = {AttributeType.STRING, nil},
	},
	DoorCombatSpawn = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, ""},
	},
	DoorGlass = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
	},
	DoorMetal = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		EasyKick = {AttributeType.BOOL, nil},
		Jammed = {AttributeType.BOOL, nil},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
	},
	DoorMetalElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
	},
	DoorPushLeft = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		DifficultDrill = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
	},
	DoorWood = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
	},
	DoorWoodElectronic = {
		LockBack = {AttributeType.EXPRESSION, false},
		LockFront = {AttributeType.EXPRESSION, false},
		DoubleDoor = {AttributeType.EXPRESSION, false},
		RemoteUnlock = {AttributeType.EXPRESSION, ""},
		PathIgnoreUnlocked = {AttributeType.INT, 0},
		PathIgnoreOpen = {AttributeType.INT, 0},
		PathIgnoreBroken = {AttributeType.INT, 0},
		PathRecover = {AttributeType.INT, 0},
		BotCloseCondition = {AttributeType.EXPRESSION, ""},
		Blocked = {AttributeType.EXPRESSION, ""},
		BlockedFromDirection = {AttributeType.EXPRESSION, nil},
		NoKick = {AttributeType.EXPRESSION, false},
		AutoLock = {AttributeType.EXPRESSION, false},
		PathReq1 = {AttributeType.STRING, ""},
		PathReq2 = {AttributeType.STRING, ""},
		Access = {AttributeType.STRING, ""},
		FailsafeUnlock = {AttributeType.EXPRESSION, ""},
		DifficultLock = {AttributeType.EXPRESSION, false},
		AlarmVariable = {AttributeType.STATE_VALUE, ""},
		AlarmDisabled = {AttributeType.EXPRESSION, ""},
		BotRelockCondition = {AttributeType.EXPRESSION, ""},
		KeepClosed = {AttributeType.INT, 0},
		KnockResponder = {AttributeType.STRING, nil},
		KnockChatResponse = {AttributeType.STRING, nil},
		HoldDirection = {AttributeType.EXPRESSION, ""},
		OpenVariable = {AttributeType.STATE_VALUE, ""},
	},
	DoubleVaultDoor = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	Elevator = {
	},
	ElevatorCallButton = {
		CallVariable = {AttributeType.STATE_VALUE, ""},
		DisabledInCombat = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
	},
	ElevatorCardReader = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DisabledInCombat = {AttributeType.BOOL, false},
	},
	EventPumpkin = {
		CounterVariable = {AttributeType.STATE_VALUE, ""},
	},
	FallingLadder = {
		LiftScale = {AttributeType.NUMBER, 0.8},
		CanShoot = {AttributeType.BOOL, false},
		LoweredVariable = {AttributeType.STATE_VALUE, ""},
	},
	Flare = {
		PlacedVariable = {AttributeType.STATE_VALUE, "FlarePlaced"},
	},
	FloorAccessCover = {
		CanOpen = {AttributeType.EXPRESSION, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
	},
	Flowerpot = {
		Seed = {AttributeType.INT, 0},
	},
	FlyingHelicopter = {
	},
	FreestandingSafe = {
		Seed = {AttributeType.INT, 1},
		CanInteract = {AttributeType.EXPRESSION, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
	},
	GarageDoor = {
		Height = {AttributeType.EXPRESSION, "0"},
	},
	GlassKitchenTable = {
	},
	HackableComputer = {
		MonitorOffset = {AttributeType.VECTOR3, Vector3.new(0, 0, 0)},
		MonitorAngle = {AttributeType.NUMBER, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 0},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, "0"},
		OldMonitor = {AttributeType.BOOL, false},
		PhysicalAccessBlocked = {AttributeType.EXPRESSION, "0"},
	},
	HeavySecurityDoor = {
		ServerExplosiveFullDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveNoDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosivePartialDamageVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveFullDamageVariable = {AttributeType.STATE_VALUE, ""},
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	Helicopter = {
		ActiveCondition = {AttributeType.EXPRESSION, ""},
		StopAttemptDialogue = {AttributeType.STRING, ""},
		StartupTime = {AttributeType.EXPRESSION, "60"},
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		PoliceShutdownVariable = {AttributeType.STATE_VALUE, ""},
		QuadBlade = {AttributeType.BOOL, false},
	},
	HiddenWallSafe = {
		PromptVisible = {AttributeType.EXPRESSION, ""},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		Seed = {AttributeType.INT, 1},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.INT, 0},
		ItemRotationY = {AttributeType.INT, 0},
		ItemRotationZ = {AttributeType.INT, 0},
		Image = {AttributeType.INT, 0},
		SafeLocatedVariable = {AttributeType.STATE_VALUE, ""},
		CoverColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		OffsetX = {AttributeType.NUMBER, 0},
		KeyItem = {AttributeType.BOOL, false},
		CoverMaterial = {AttributeType.STRING, ""},
		SafeTag = {AttributeType.STRING, ""},
		HiddenShuffleId = {AttributeType.STRING, ""},
		Reinforced = {AttributeType.EXPRESSION, ""},
		ReinforcedColor0 = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(1, 1, 1)},
		ReinforcedColor1 = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(1, 1, 1)},
	},
	IndustrialShelvesSmall = {
		BoxSeed = {AttributeType.INT, 0},
		BoxDensity = {AttributeType.NUMBER, 0},
		BoxColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
	},
	InteractionBlocker = {
		ServerActive = {AttributeType.EXPRESSION, "1"},
		ClientActive = {AttributeType.EXPRESSION, nil},
	},
	IntroCam = {
	},
	Ladder = {
		Decorative = {AttributeType.BOOL, false},
	},
	LandscapePhotoHorizontalRectangle = {
		Image = {AttributeType.INT, 0},
	},
	LandscapePhotoSquare = {
		Image = {AttributeType.INT, 0},
	},
	LandscapePhotoVerticalThird = {
		Image = {AttributeType.INT, 0},
		OffsetX = {AttributeType.NUMBER, 0},
	},
	Laptop = {
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, "0"},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
	},
	LaptopOld = {
		DesktopBackground = {AttributeType.STRING, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, "0"},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
	},
	LaundryBasket = {
		Active = {AttributeType.EXPRESSION, ""},
		Disguise = {AttributeType.STRING, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		ClientUsedVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.EXPRESSION, "0"},
	},
	LeverageMove = {
		MoveDist = {AttributeType.EXPRESSION, "0"},
		Prop = {AttributeType.STRING, ""},
		MovedToEndVariable = {AttributeType.STATE_VALUE, ""},
		MovedFromStartVariable = {AttributeType.STATE_VALUE, ""},
		VisibleCondition = {AttributeType.EXPRESSION, "1"},
		Heavy = {AttributeType.BOOL, true},
	},
	LongCoffeeTable = {
		Seed = {AttributeType.INT, 0},
	},
	LootCash = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LootCash2 = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LootThermite = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
	},
	LootWeapons = {
		ItemTagString = {AttributeType.STRING, ""},
	},
	LowVent = {
		Blocked = {AttributeType.EXPRESSION, ""},
	},
	MetalDetector = {
		PowerLevel = {AttributeType.EXPRESSION, ""},
	},
	MinimapBlock = {
	},
	Monitor = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
	},
	NetworkSwitch = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		TriggerInvestigation = {AttributeType.EXPRESSION, true},
	},
	NoDropZone = {
		BlockPickups = {AttributeType.BOOL, false},
	},
	OldMonitor = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		ScreenText = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
	},
	OneWayTrespass = {
		Condition = {AttributeType.EXPRESSION, ""},
		EnforceClass = {AttributeType.STRING, ""},
		MajorTrespass = {AttributeType.BOOL, false},
		SetMetaTagsOnWarp = {AttributeType.STRING, nil},
		ConfrontationDialogue = {AttributeType.STRING, nil},
	},
	PortableMetalDetector = {
		PowerLevel = {AttributeType.EXPRESSION, ""},
	},
	PowerBoxLarge = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		InvestigatorTag = {AttributeType.STRING, nil},
	},
	PowerBoxPortable = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		Locked = {AttributeType.BOOL, false},
		ObjectName = {AttributeType.STRING, ""},
		PowerAreaParent = {AttributeType.STATE_VALUE, ""},
		ManualInvestigationBot = {AttributeType.EXPRESSION, ""},
		InvestigatorTag = {AttributeType.STRING, nil},
	},
	PowerBoxSmall = {
		TagWhileActive = {AttributeType.BOOL, false},
		AllowDisabling = {AttributeType.EXPRESSION, "1"},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		CombatDisableTarget = {AttributeType.EXPRESSION, ""},
		NoPropDamage = {AttributeType.EXPRESSION, ""},
		AllowRestoring = {AttributeType.EXPRESSION, "1"},
		Locked = {AttributeType.BOOL, false},
		ObjectName = {AttributeType.STRING, ""},
		PowerAreaParent = {AttributeType.STATE_VALUE, ""},
		ManualInvestigationBot = {AttributeType.EXPRESSION, ""},
		InvestigatorTag = {AttributeType.STRING, nil},
	},
	PropBase = {
	},
	RadioStation = {
		SocialEngineeringLevel = {AttributeType.INT, 1},
		DistractionDisabled = {AttributeType.EXPRESSION, ""},
		DistractionActive = {AttributeType.EXPRESSION, ""},
		DistractionVariable = {AttributeType.STATE_VALUE, ""},
		DistractionDialogue = {AttributeType.STRING, ""},
		DistractionSubtitle = {AttributeType.STRING, ""},
		Enabled = {AttributeType.EXPRESSION, "1"},
	},
	ScalablePlanter = {
		PlantHeight = {AttributeType.NUMBER, 3},
		PlantWidth = {AttributeType.NUMBER, 0},
	},
	ScalableWallPlanter = {
		PlantWidth = {AttributeType.NUMBER, 1},
		PlantHeight = {AttributeType.NUMBER, 2},
	},
	SearchableFilingCabinets = {
		FilesSpawned = {AttributeType.EXPRESSION, ""},
		KeyItem = {AttributeType.BOOL, false},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemTagString = {AttributeType.STRING, ""},
	},
	SecurityCamera = {
		AngleMax = {AttributeType.STRING, "0"},
		AngleMin = {AttributeType.STRING, "0"},
		Exterior = {AttributeType.BOOL, true},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		NetworkDestination = {AttributeType.NETWORK_ID_STRING, ""},
		CamSet = {AttributeType.STRING, ""},
		CameraArea = {AttributeType.STRING, ""},
		AngleDown = {AttributeType.NUMBER, 0},
		Wireless = {AttributeType.BOOL, true},
		CamNumber = {AttributeType.INT, 0},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		LocationKey = {AttributeType.STRING, ""},
		MapFloorOffset = {AttributeType.INT, 0},
		CycleTime = {AttributeType.NUMBER, 0},
		WarpPoint = {AttributeType.STRING, nil},
	},
	ServerRack = {
		CanPickup = {AttributeType.BOOL, false},
		ItemTagString = {AttributeType.STRING, ""},
		PickupVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STRING, ""},
	},
	ServerRackWideTerminal = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Disconnected = {AttributeType.EXPRESSION, ""},
		DesktopTransparency = {AttributeType.NUMBER, 0},
		DesktopBackground = {AttributeType.STRING, ""},
		UseOldMonitor = {AttributeType.OPTIONAL_BOOL, false},
		ScreenText = {AttributeType.EXPRESSION, ""},
		NetworkNameTag = {AttributeType.STRING, ""},
		PasswordDifficulty = {AttributeType.EXPRESSION, ""},
		PasswordUnlockedVariable = {AttributeType.STATE_VALUE, ""},
		PasswordLockedCondition = {AttributeType.EXPRESSION, ""},
		ManualPasswordVariable = {AttributeType.STATE_VALUE, ""},
		ManualPasswordList = {AttributeType.STRING, ""},
		ManualPasswordRevealed = {AttributeType.EXPRESSION, ""},
		SecurityKeyNeeded = {AttributeType.EXPRESSION, ""},
		SecurityKeyInsertedVariable = {AttributeType.STATE_VALUE, ""},
	},
	StaticAmmoBox = {
	},
	SurfaceText = {
		TextKey = {AttributeType.STRING, ""},
		Font = {AttributeType.STRING, ""},
		HorizontalAlignment = {AttributeType.INT, 2},
		TextColor3 = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(1, 1, 1)},
	},
	TableGlass = {
	},
	TableGlassLarge = {
	},
	ThermiteBurn = {
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		StartedVariable = {AttributeType.STATE_VALUE, ""},
		BurnTime = {AttributeType.EXPRESSION, "90"},
	},
	ThinBush = {
	},
	TimelockCodePanel = {
		GlobalCountdownState = {AttributeType.STATE_VALUE, ""},
		CompletedVariable = {AttributeType.STATE_VALUE, ""},
		TimelockEnabled = {AttributeType.EXPRESSION, ""},
		SetState = {AttributeType.STATE_VALUE, ""},
		CountTime = {AttributeType.NUMBER, 60},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		SetValue = {AttributeType.EXPRESSION, ""},
	},
	TrespassZoneDisplay = {
		Enabled = {AttributeType.BOOL, true},
	},
	TriggerLocalChat = {
		Id = {AttributeType.STRING, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerVision = {
		Hold = {AttributeType.NUMBER, 0},
		Dist = {AttributeType.NUMBER, 40},
		ZoneSize = {AttributeType.NUMBER, 0.8},
		Active = {AttributeType.EXPRESSION, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerZone = {
		IsGlobal = {AttributeType.BOOL, false},
		IsLocal = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		Variable = {AttributeType.STATE_VALUE, ""},
		HighlightZone = {AttributeType.BOOL, false},
		UpdateFrequency = {AttributeType.NUMBER, 1},
		ClearOnInactive = {AttributeType.BOOL, false},
		Disguise = {AttributeType.STRING, nil},
		SetMetaTags = {AttributeType.STRING, nil},
	},
	TutorialText = {
		HorizontalOffset = {AttributeType.NUMBER, 0.5},
		VerticalOffset = {AttributeType.NUMBER, 0.5},
		Text = {AttributeType.STRING, ""},
		Visible = {AttributeType.EXPRESSION, "1"},
"	"},
	Van = {
		IsOpen = {AttributeType.EXPRESSION, ""},
		DoorAngleR = {AttributeType.EXPRESSION, "0"},
		DoorAngleL = {AttributeType.EXPRESSION, "0"},
	},
	VaultOpenRight = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
	},
	WallMountedCoreDrill = {
		TriggerTag = {AttributeType.STRING, ""},
		AssembleVariable = {AttributeType.STATE_VALUE, ""},
		FinishedVariable = {AttributeType.STATE_VALUE, ""},
		RemovedVariable = {AttributeType.STATE_VALUE, ""},
		MovePrompt = {AttributeType.BOOL, false},
		PreAssembled = {AttributeType.BOOL, false},
		DrillTime = {AttributeType.EXPRESSION, "60"},
	},
	WallSafe = {
		Seed = {AttributeType.INT, 1},
		CanInteract = {AttributeType.EXPRESSION, ""},
		CodeRevealedVariable = {AttributeType.STATE_VALUE, ""},
		ExplosiveOpenVariable = {AttributeType.STATE_VALUE, ""},
		OpenedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRotationX = {AttributeType.NUMBER, 0},
		ItemRotationY = {AttributeType.NUMBER, 0},
		ItemRotationZ = {AttributeType.NUMBER, 0},
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		KeyItem = {AttributeType.BOOL, false},
	},
	Window = {
		Bulletproof = {AttributeType.EXPRESSION, false},
		StateValue = {AttributeType.STATE_VALUE, nil},
		StateVariable = {AttributeType.STATE_VALUE, ""},
		GlassColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		NoFrame = {AttributeType.BOOL, false},
		SlideOpen = {AttributeType.EXPRESSION, ""},
		SlideDist = {AttributeType.NUMBER, 0},
	},
	WindowClimb = {
		Blocked = {AttributeType.EXPRESSION, ""},
		Vertical = {AttributeType.BOOL, false},
	},
	WoodChair = {
	},
	WoodShootingTarget = {
		TargetDownVariable = {AttributeType.STATE_VALUE, ""},
	},
	WoodTargetWithSensor = {
	},
	LandscapePhotoIds = {
	},
	AccessRequestNode = {
		ServerCondition = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		ToolRequired = {AttributeType.STRING, ""},
		AccessVariable = {AttributeType.STATE_VALUE, ""},
		TriggeredVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		BotServerTag = {AttributeType.STRING, ""},
		AccessOnceVariable = {AttributeType.STATE_VALUE, ""},
		AccessTime = {AttributeType.NUMBER, 1},
	},
	AlarmButton = {
	},
	ArmoredTruck = {
	},
	BagSpawn = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
		BagColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		BagType = {AttributeType.STRING, "Backpack"},
		ModelHidden = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0.5},
		ItemRemovedVariable = {AttributeType.STRING, ""},
		Contents = {AttributeType.STRING, ""},
	},
	BasicPart = {
		Material = {AttributeType.STRING, "SmoothPlastic"},
		ColorHex = {AttributeType.STRING, "FFFFFF"},
	},
	BiometricLock = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
		RewireEnabled = {AttributeType.EXPRESSION, ""},
	},
	BotConversationPoint = {
		BotTag0 = {AttributeType.STRING, ""},
		BotTag1 = {AttributeType.STRING, ""},
		TriggerRange = {AttributeType.INT, 40},
		CanStartConversation = {AttributeType.EXPRESSION, ""},
		Dialogue0 = {AttributeType.STRING, nil},
		Dialogue0Speaker = {AttributeType.INT, nil},
		Dialogue0Time = {AttributeType.NUMBER, nil},
		Dialogue0Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue1 = {AttributeType.STRING, nil},
		Dialogue1Speaker = {AttributeType.INT, nil},
		Dialogue1Time = {AttributeType.NUMBER, nil},
		Dialogue1Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue2 = {AttributeType.STRING, nil},
		Dialogue2Speaker = {AttributeType.INT, nil},
		Dialogue2Time = {AttributeType.NUMBER, nil},
		Dialogue2Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue3 = {AttributeType.STRING, nil},
		Dialogue3Speaker = {AttributeType.INT, nil},
		Dialogue3Time = {AttributeType.NUMBER, nil},
		Dialogue3Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue4 = {AttributeType.STRING, nil},
		Dialogue4Speaker = {AttributeType.INT, nil},
		Dialogue4Time = {AttributeType.NUMBER, nil},
		Dialogue4Variable = {AttributeType.STATE_VALUE, nil},
		Dialogue5 = {AttributeType.STRING, nil},
		Dialogue5Speaker = {AttributeType.INT, nil},
		Dialogue5Time = {AttributeType.NUMBER, nil},
		Dialogue5Variable = {AttributeType.STATE_VALUE, nil},
	},
	Cabinet = {
		BodyHiddenVariable = {AttributeType.STATE_VALUE, ""},
	},
	ConditionalHighJumpRequired = {
		Climber3Condition = {AttributeType.EXPRESSION, "1"},
		Color = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		Material = {AttributeType.STRING, "Plastic"},
	},
	ControlPanel = {
		UsedVariable = {AttributeType.STATE_VALUE, ""},
	},
	CustomReportPoint = {
		Hidden = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		CameraOnly = {AttributeType.BOOL, false},
		AutoAlertBotTag = {AttributeType.STRING, ""},
		Visibility = {AttributeType.NUMBER, 1},
		RaiseAlert = {AttributeType.INT, 1},
		MinAlert = {AttributeType.INT, 1},
		MaxAlert = {AttributeType.INT, 3},
		NotificationMessage = {AttributeType.STRING, ""},
		ReportDialogue = {AttributeType.STRING, ""},
	},
	DebugSpawnLocation = {
		Active = {AttributeType.BOOL, false},
	},
	DynamicNode = {
		Id = {AttributeType.STRING, ""},
		TakedownImmunity = {AttributeType.BOOL, false},
		Anim = {AttributeType.STRING, nil},
		CaptureBot = {AttributeType.EXPRESSION, nil},
		CustomBehavior = {AttributeType.STRING, nil},
	},
	ElevatorFunctional = {
		OpenCondition = {AttributeType.EXPRESSION, ""},
		PlayerInElevatorVariable = {AttributeType.STATE_VALUE, ""},
		BotInElevator = {AttributeType.STATE_VALUE, ""},
		UsedVariable = {AttributeType.STATE_VALUE, ""},
		LinkedElevator = {AttributeType.STRING, ""},
		NoUsing = {AttributeType.BOOL, false},
		NoDropBlocking = {AttributeType.BOOL, false},
		WarpTargetId = {AttributeType.STRING, ""},
		WarpPointId = {AttributeType.STRING, ""},
	},
	EscapeZone = {
		Active = {AttributeType.EXPRESSION, ""},
	},
	FlowStart = {
	},
	FreeTrigger = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		DisabledSubtitle = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 0.5},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		SaveProgress = {AttributeType.BOOL, false},
		Tool = {AttributeType.STRING, ""},
		LinkToProp = {AttributeType.BOOL, false},
		HiddenShuffleId = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetValue = {AttributeType.EXPRESSION, ""},
		SetClientVariable = {AttributeType.STATE_VALUE, ""},
		TagWhileVisible = {AttributeType.BOOL, false},
		Debug = {AttributeType.BOOL, false},
		IncrementClientVariable = {AttributeType.STATE_VALUE, ""},
		IncrementVariable = {AttributeType.STATE_VALUE, ""},
		OmniDir = {AttributeType.BOOL, false},
	},
	GuardCombatNode = {
		BotTag = {AttributeType.STRING, nil},
	},
	init = {
	},
	IntercomCode = {
		SocialEngineeringDialogue = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		HostageUse = {AttributeType.STATE_VALUE, ""},
		PickupNode = {AttributeType.STRING, ""},
		PickupVariable = {AttributeType.STATE_VALUE, ""},
		CallCondition = {AttributeType.EXPRESSION, ""},
		CallConditionPrompt = {AttributeType.STRING, ""},
		OpenedWithBluffVariable = {AttributeType.STATE_VALUE, ""},
		OpenedWithHostageVariable = {AttributeType.STATE_VALUE, ""},
		SocialEngineeringLevel = {AttributeType.NUMBER, 0},
		Responder = {AttributeType.STRING, ""},
	},
	IntercomPanel = {
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		PowerArea = {AttributeType.STATE_VALUE, ""},
		Subtitle = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
	},
	InvestigationStandTrigger = {
		ActiveCondition = {AttributeType.EXPRESSION, ""},
		HighPriority = {AttributeType.BOOL, false},
		BotServerTag = {AttributeType.STRING, ""},
		ArrivalVariableDelay = {AttributeType.NUMBER, 0},
		ArrivalVariable = {AttributeType.STATE_VALUE, ""},
		Anim = {AttributeType.STRING, ""},
		Timeout = {AttributeType.NUMBER, 0},
		CallDialogue = {AttributeType.STRING, ""},
	},
	InvestigationTrigger = {
	},
	ItemDeposit = {
		SubtitleKey = {AttributeType.STRING, ""},
		DepositedVariable = {AttributeType.STATE_VALUE, ""},
		ItemTagForDeposit = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		TitleKey = {AttributeType.STRING, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ClientEnabled = {AttributeType.EXPRESSION, ""},
		MissingToolSubtitle = {AttributeType.STRING, ""},
		MissingToolTitle = {AttributeType.STRING, ""},
		Item = {AttributeType.STRING, ""},
		SetMetaTags = {AttributeType.STRING, nil},
	},
	ItemSpawn = {
		Item = {AttributeType.STRING, ""},
		ItemTagString = {AttributeType.STRING, ""},
		ModelHidden = {AttributeType.BOOL, false},
		FlatTrigger = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0},
		PickupCondition = {AttributeType.EXPRESSION, ""},
		KeyItem = {AttributeType.BOOL, false},
		ItemRemovedVariable = {AttributeType.STATE_VALUE, ""},
		IsSpawned = {AttributeType.EXPRESSION, ""},
		HasAmmo = {AttributeType.BOOL, false},
	},
	KillZone = {
		BotServerTag = {AttributeType.STRING, ""},
		KillerInZone = {AttributeType.BOOL, false},
		TargetInZone = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		KillCountVariable = {AttributeType.STATE_VALUE, ""},
	},
	LeaningCover = {
		AllowSpawning = {AttributeType.EXPRESSION, false},
		Enabled = {AttributeType.EXPRESSION, true},
		SpawnsIgnoreProximity = {AttributeType.BOOL, false},
		UseFromAdjacentRoom = {AttributeType.BOOL, false},
		HoldDoor = {AttributeType.BOOL, false},
		ReverseDoor = {AttributeType.BOOL, false},
		CoverTag = {AttributeType.STRING, ""},
		HoldPriority = {AttributeType.EXPRESSION, "0"},
		LeanRight = {AttributeType.BOOL, false},
	},
	LeaveMissionPoint = {
	},
	LootCountZone = {
	},
	LootGeneric = {
		ItemTagString = {AttributeType.STATE_VALUE, ""},
		BagColor = {AttributeType.OPTIONAL_MISSION_COLOR, Color3.new(0, 0, 0)},
		BagType = {AttributeType.STRING, "Backpack"},
		ModelHidden = {AttributeType.BOOL, false},
		InitialPickupTime = {AttributeType.NUMBER, 0.5},
		ItemRemovedVariable = {AttributeType.STRING, ""},
		Contents = {AttributeType.STRING, ""},
	},
	MissionEndZone = {
		PlayersExitedVariable = {AttributeType.STATE_VALUE, ""},
		ItemRequired = {AttributeType.STRING, ""},
		ItemSecuredVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		OpenForAll = {AttributeType.EXPRESSION, ""},
		HighlightZone = {AttributeType.BOOL, true},
		AltItem0 = {AttributeType.STRING, nil},
		AltItem1 = {AttributeType.STRING, nil},
		AltItem2 = {AttributeType.STRING, nil},
		AltItem0Variable = {AttributeType.STATE_VALUE, nil},
		AltItem1Variable = {AttributeType.STATE_VALUE, nil},
		AltItem2Variable = {AttributeType.STATE_VALUE, nil},
	},
	MissionExit = {
	},
	PathfindingBlocker = {
		BotCollisions = {AttributeType.BOOL, nil},
	},
	PlaceholderProp = {
	},
	PointOfInterest = {
		Icon = {AttributeType.STRING, ""},
		IconScale = {AttributeType.NUMBER, 1},
	},
	PowerRoomProp1 = {
		PowerArea = {AttributeType.STRING, ""},
		DetectSabotage = {AttributeType.BOOL, true},
		DamagedVariable = {AttributeType.STATE_VALUE, ""},
		Health = {AttributeType.INT, 0},
	},
	PowerRoomProp2 = {
		PowerArea = {AttributeType.STRING, ""},
		DetectSabotage = {AttributeType.BOOL, true},
		DamagedVariable = {AttributeType.STATE_VALUE, ""},
		Health = {AttributeType.INT, 0},
	},
	RandomBotSpawnLocation = {
		StartingSpawnOnly = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, true},
	},
	RewireablePanel = {
		PowerArea = {AttributeType.STATE_VALUE, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		RewireEnabled = {AttributeType.EXPRESSION, "1"},
		ObjectName = {AttributeType.STRING, ""},
		DifficultRewire = {AttributeType.BOOL, false},
	},
	SawCutPoint = {
	},
	ScriptedExplosion = {
		BlastRadius = {AttributeType.NUMBER, 20},
		Active = {AttributeType.EXPRESSION, ""},
	},
	SearchableClipboard = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetClientVariable = {AttributeType.STATE_VALUE, ""},
	},
	SearchableFile = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
	},
	SearchablePaperTray = {
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		ServerVisible = {AttributeType.EXPRESSION, ""},
		ClientVisible = {AttributeType.EXPRESSION, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		HoldTime = {AttributeType.NUMBER, 2},
		HoldAlert = {AttributeType.EXPRESSION, ""},
		DisabledTitle = {AttributeType.EXPRESSION, ""},
		DisabledSubtitle = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
	},
	ShuffleTarget = {
		ShuffleTag = {AttributeType.STRING, ""},
		MatchVariable = {AttributeType.STATE_VALUE, ""},
		MatchValue = {AttributeType.EXPRESSION, nil},
		ResolvePriority = {AttributeType.INT, nil},
	},
	SoundSource = {
		SoundId = {AttributeType.EXPRESSION, "0"},
		Volume = {AttributeType.NUMBER, 0.5},
		Looped = {AttributeType.BOOL, false},
		Active = {AttributeType.EXPRESSION, ""},
		SoundLength = {AttributeType.NUMBER, 0},
		RollOffMaxDistance = {AttributeType.NUMBER, 10000},
		RollOffMinDistance = {AttributeType.NUMBER, 10},
	},
	SpawnLocation = {
	},
	StandingCover = {
		AllowSpawning = {AttributeType.EXPRESSION, false},
		Enabled = {AttributeType.EXPRESSION, true},
		SpawnsIgnoreProximity = {AttributeType.BOOL, false},
		UseFromAdjacentRoom = {AttributeType.BOOL, false},
		HoldDoor = {AttributeType.BOOL, false},
		ReverseDoor = {AttributeType.BOOL, false},
		CoverTag = {AttributeType.STRING, ""},
		HoldPriority = {AttributeType.EXPRESSION, "0"},
	},
	StateScriptPart = {
	},
	TriggerHit = {
	},
	TriggerRoom = {
		Active = {AttributeType.EXPRESSION, ""},
		PlayersInRoomVariable = {AttributeType.STATE_VALUE, ""},
		ClientInRoomVariable = {AttributeType.STATE_VALUE, ""},
	},
	TriggerRoomBot = {
		BotServerTag = {AttributeType.STRING, ""},
		ActiveCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerThreshhold = {
		PlayersBeforeThreshholdVariable = {AttributeType.STATE_VALUE, ""},
		PlayersAfterThreshholdVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	TriggerZoneBot = {
		RagdollCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		DeathCountVariable = {AttributeType.STATE_VALUE, ""},
		WalkingCountVariable = {AttributeType.STATE_VALUE, ""},
		ConciousCountVariable = {AttributeType.STATE_VALUE, ""},
		CountVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	VisionBlocker = {
	},
	WarpPoint = {
		WarpPointId = {AttributeType.STRING, ""},
		WarpTargetId = {AttributeType.STRING, ""},
		WarpOnHit = {AttributeType.EXPRESSION, ""},
		WarpKeepsOffset = {AttributeType.BOOL, true},
		WarpOnIncrement = {AttributeType.EXPRESSION, ""},
		WarpHostages = {AttributeType.BOOL, true},
	},
	AlarmedBehaviorOverride = {
		BotServerTag = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
	},
	AlertRaiseCondition = {
		Amount = {AttributeType.INT, 1},
		MinValue = {AttributeType.INT, 1},
		MaxValue = {AttributeType.INT, 3},
		Reason = {AttributeType.STRING, ""},
		Condition = {AttributeType.EXPRESSION, ""},
	},
	BodyAltTrigger = {
		BotServerTag = {AttributeType.STRING, ""},
		HoldTime = {AttributeType.NUMBER, 1},
		TitleKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		TriggerNotification = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		BotClientTag = {AttributeType.STRING, ""},
		ClientVisible = {AttributeType.EXPRESSION, "1"},
		ServerEnabled = {AttributeType.EXPRESSION, "1"},
	},
	BotAltTrigger = {
		BotClientTag = {AttributeType.STRING, ""},
		BotServerTag = {AttributeType.STRING, ""},
		ServerEnabled = {AttributeType.EXPRESSION, ""},
		AllowHostages = {AttributeType.BOOL, false},
		TriggerNotification = {AttributeType.STRING, ""},
		TriggerLocalNotification = {AttributeType.STRING, ""},
		TriggerVariable = {AttributeType.STATE_VALUE, ""},
		TriggerClientVariable = {AttributeType.STATE_VALUE, ""},
		TitleKey = {AttributeType.STRING, ""},
		AllowPatroling = {AttributeType.BOOL, false},
		ClientVisible = {AttributeType.EXPRESSION, "1"},
		HoldTime = {AttributeType.NUMBER, 1},
		SubtitleKey = {AttributeType.STRING, ""},
	},
	BotItemSpawn = {
		Condition = {AttributeType.EXPRESSION, ""},
		Item = {AttributeType.STRING, ""},
		ItemTag = {AttributeType.STRING, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	BotStateTracker = {
		IncapacitationCountVariable = {AttributeType.STATE_VALUE, ""},
		HostageCountVariable = {AttributeType.STATE_VALUE, ""},
		DeathCountVariable = {AttributeType.STATE_VALUE, ""},
		FleeCountVariable = {AttributeType.STATE_VALUE, ""},
		TotalCountVariable = {AttributeType.STATE_VALUE, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	CombatSpawner = {
		ReinforcementPool = {AttributeType.STRING, ""},
		TimeBetweenSpawns = {AttributeType.EXPRESSION, ""},
		EnemyWeapons = {AttributeType.STRING, ""},
		SpawnTags = {AttributeType.STRING, ""},
		FlowMap = {AttributeType.STRING, ""},
		SpawnSquads = {AttributeType.BOOL, false},
		EnemyType = {AttributeType.STRING, ""},
		AllowDespawn = {AttributeType.BOOL, false},
		SpawnsBlockedVariable = {AttributeType.STATE_VALUE, ""},
		Active = {AttributeType.EXPRESSION, ""},
		SpawnCap = {AttributeType.EXPRESSION, "6"},
		EnemyWeaponsWave1 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave2 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave3 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave4 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave5 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave6 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave7 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave8 = {AttributeType.EXPRESSION, nil},
		EnemyWeaponsWave9 = {AttributeType.EXPRESSION, nil},
	},
	CombatWaveSpawner = {
	},
	ConditionalStateUpdate = {
		Watch = {AttributeType.EXPRESSION, ""},
		Condition = {AttributeType.EXPRESSION, ""},
		InactiveVariable = {AttributeType.STATE_VALUE, ""},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
	},
	ConversationGenericSocialEngineering = {
		BotServerTag = {AttributeType.STRING, ""},
		Visible = {AttributeType.EXPRESSION, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		IntimidationLevel = {AttributeType.INT, 0},
		Icon = {AttributeType.STRING, "ChatGeneric"},
		Text = {AttributeType.STRING, ""},
		Dialogue = {AttributeType.STRING, ""},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		Notification = {AttributeType.STRING, ""},
		NotificationDelay = {AttributeType.NUMBER, 2.5},
		Disguise = {AttributeType.STRING, ""},
	},
	ConversationResponseCustomBehavior = {
		BotServerTag = {AttributeType.STATE_VALUE, ""},
		DisableReason = {AttributeType.EXPRESSION, ""},
		SocialEngineeringLevel = {AttributeType.INT, 0},
		Dialogue = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
	},
	CoverFillSpawner = {
		CoverSearchLimit = {AttributeType.INT, 5},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
		SpawnsBlockedVariable = {AttributeType.STATE_VALUE, ""},
		FillFrequency = {AttributeType.NUMBER, 6},
		ReinforcementPool = {AttributeType.STRING, ""},
		UnitChanceHeavy = {AttributeType.NUMBER, 0.2},
		CoverTags = {AttributeType.STRING, ""},
		SpawnTags = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, "Mission_AlarmRaised"},
		SpawnCap = {AttributeType.EXPRESSION, "8"},
		EnemyType = {AttributeType.STRING, "Swat"},
		EnemyWeapons = {AttributeType.STRING, "F57|S97|480 MCS"},
		ServerTag = {AttributeType.STRING, nil},
	},
	CustomBehaviorCondition = {
		Priority = {AttributeType.STRING, "Custom1"},
		BotServerTag = {AttributeType.STRING, ""},
		CustomBehavior = {AttributeType.STRING, ""},
		LoopApply = {AttributeType.BOOL, false},
		Condition = {AttributeType.EXPRESSION, false},
	},
	CustomConversation = {
	},
	CustomHack = {
		DeployCost = {AttributeType.INT, 20},
		DeployTime = {AttributeType.INT, 10},
		NodeId = {AttributeType.NETWORK_ID, 1},
		NameKey = {AttributeType.STRING, ""},
		SubtitleKey = {AttributeType.STRING, ""},
		DescriptionKey = {AttributeType.STRING, ""},
		BlockDeallocation = {AttributeType.BOOL, false},
		ProgressVariable = {AttributeType.STATE_VALUE, ""},
		PauseCondition = {AttributeType.EXPRESSION, ""},
		Priority = {AttributeType.INT, 0},
		Difficulty = {AttributeType.EXPRESSION, ""},
		Suspicion = {AttributeType.INT, 1},
		PrimaryHack = {AttributeType.BOOL, false},
		Visible = {AttributeType.EXPRESSION, "1"},
		DeployedVariable = {AttributeType.STATE_VALUE, ""},
		DeployedOnceVariable = {AttributeType.STATE_VALUE, ""},
		ScriptedBehavior = {AttributeType.STRING, ""},
		DisableReason = {AttributeType.EXPRESSION, ""},
		IconId = {AttributeType.EXPRESSION, "0"},
		IsDeployedVariable = {AttributeType.STATE_VALUE, ""},
	},
	DelayedStateUpdate = {
		Watch = {AttributeType.EXPRESSION, ""},
		DelayTime = {AttributeType.EXPRESSION, "5"},
		SetVariable = {AttributeType.STATE_VALUE, ""},
		OnlyMatch = {AttributeType.BOOL, false},
	},
	HackableDoor = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	HackableElevator = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	HackingNodeStatus = {
		NetworkId = {AttributeType.NETWORK_ID, 1},
		DisabledVariable = {AttributeType.STATE_VALUE, ""},
		CompromisedVariable = {AttributeType.STATE_VALUE, ""},
	},
	HiddenShuffle = {
		HiddenShuffleId = {AttributeType.STRING, ""},
		FrontCount = {AttributeType.INT, 0},
		BackCount = {AttributeType.INT, 0},
		RevealCount = {AttributeType.INT, 1},
		RevealCountVariable = {AttributeType.STATE_VALUE, ""},
		FailCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientFailCountVariable = {AttributeType.STATE_VALUE, ""},
		Seed = {AttributeType.INT, 1},
		RevealAllCondition = {AttributeType.EXPRESSION, ""},
	},
	ItemStateTracker = {
		GroundCountVariable = {AttributeType.STATE_VALUE, ""},
		TotalHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		BotHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		ClientHeldCountVariable = {AttributeType.STATE_VALUE, ""},
		ItemTag = {AttributeType.STRING, ""},
	},
	ItemSwapCondition = {
		Condition = {AttributeType.EXPRESSION, ""},
		SwapItemType = {AttributeType.STRING, ""},
		SwapItemTag = {AttributeType.STRING, ""},
		TargetItemTag = {AttributeType.STRING, ""},
	},
	LerpOperation = {
		OutputVariable = {AttributeType.STATE_VALUE, ""},
		Value0 = {AttributeType.EXPRESSION, ""},
		Value1 = {AttributeType.EXPRESSION, ""},
		Delta = {AttributeType.EXPRESSION, "0.5"},
		AlwaysUpdate = {AttributeType.EXPRESSION, false},
		UpdateClock = {AttributeType.EXPRESSION, "0"},
	},
	MissionCompletionTrigger = {
		Condition = {AttributeType.EXPRESSION, ""},
		Timeout = {AttributeType.NUMBER, 1},
		CompleteVariable = {AttributeType.STATE_VALUE, ""},
	},
	MissionFailedTrigger = {
		Condition = {AttributeType.EXPRESSION, ""},
		Timeout = {AttributeType.NUMBER, 1},
		FailedVariable = {AttributeType.STATE_VALUE, ""},
	},
	NetworkRouter = {
		NetworkId = {AttributeType.NETWORK_ID, 999},
		NetworkLink = {AttributeType.NETWORK_ID_STRING, ""},
	},
	Notification = {
		Condition = {AttributeType.EXPRESSION, ""},
		Notification = {AttributeType.STRING, ""},
	},
	RandomBotSpawner = {
		SpawningActive = {AttributeType.EXPRESSION, ""},
		SpawnTimeMin = {AttributeType.NUMBER, 4},
		SpawnTimeMax = {AttributeType.NUMBER, 10},
		Behavior = {AttributeType.STRING, ""},
		Class = {AttributeType.STRING, ""},
		CivilianHighlight = {AttributeType.BOOL, false},
		DetectionSpeed = {AttributeType.NUMBER, 1},
		NodesBreak = {AttributeType.STRING, ""},
		EnforceClass = {AttributeType.STRING, ""},
		Profile = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
		Outfit = {AttributeType.STRING, ""},
		Nodes = {AttributeType.STRING, ""},
		HostageDifficulty = {AttributeType.NUMBER, 0},
		ObjectiveHighlight = {AttributeType.BOOL, false},
		Weapon = {AttributeType.STRING, ""},
	},
	ReinforcementPool = {
		PoolName = {AttributeType.STRING, ""},
		WaveResetTimeMinimum = {AttributeType.NUMBER, 0},
		WaveStateVariable = {AttributeType.STATE_VALUE, ""},
		WaveVariable = {AttributeType.STATE_VALUE, ""},
		PoolLimit = {AttributeType.EXPRESSION, ""},
		RemainingVariable = {AttributeType.STATE_VALUE, ""},
		ActiveVariable = {AttributeType.STATE_VALUE, ""},
		WaveResetTime = {AttributeType.EXPRESSION, ""},
		WaveResetTimeDecrease = {AttributeType.NUMBER, 0},
	},
	ScriptedBotSpawn = {
		TemplateId = {AttributeType.STRING, ""},
		Condition = {AttributeType.EXPRESSION, ""},
	},
	SearchPatternCondition = {
		Condition = {AttributeType.EXPRESSION, ""},
		BotServerTag = {AttributeType.STRING, ""},
	},
	ServerChat = {
		Active = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		Delay = {AttributeType.NUMBER, 0},
		Chance = {AttributeType.NUMBER, 1},
		TriggerOnce = {AttributeType.BOOL, false},
	},
	SniperSpawner = {
		Active = {AttributeType.EXPRESSION, ""},
		Nodes = {AttributeType.STRING, ""},
		InitialSpawns = {AttributeType.EXPRESSION, "0"},
		RespawnRate = {AttributeType.EXPRESSION, "20"},
	},
	StateScript = {
	},
	TargetLureHack = {
	},
	TimerComponent = {
		SetVariable = {AttributeType.STATE_VALUE, ""},
		SetFormattedVariable = {AttributeType.STATE_VALUE, ""},
		StartValue = {AttributeType.EXPRESSION, "0"},
		TargetValue = {AttributeType.EXPRESSION, "60"},
		Increment = {AttributeType.EXPRESSION, "1"},
		Offset = {AttributeType.EXPRESSION, ""},
		Enabled = {AttributeType.EXPRESSION, ""},
	},
	TrackBotsDown = {
	},
	TrackItemHeldServer = {
	},
	TrackNodeReserved = {
	},
	AutoConversationTrigger = {
		BotClientTag = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	BlackoutScreen = {
		Active = {AttributeType.EXPRESSION, ""},
	},
	FileUITrigger = {
		Trigger = {AttributeType.EXPRESSION, ""},
		Lines = {AttributeType.STRING, ""},
	},
	GameCredits = {
	},
	HackingNodeHighlight = {
		HackDesc = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
		IncludeTraversal = {AttributeType.BOOL, false},
		NodeId = {AttributeType.NETWORK_ID, 0},
		ObjectiveType = {AttributeType.INT, 1},
	},
	LocalChat = {
		DelayStart = {AttributeType.NUMBER, 0},
		Active = {AttributeType.EXPRESSION, ""},
		Dialogue = {AttributeType.STRING, ""},
		TriggerOnce = {AttributeType.BOOL, false},
		StealthOnly = {AttributeType.BOOL, false},
	},
	LocalStateComponents = {
	},
	LocalWeaponTracker = {
		TotalAmmoVariable = {AttributeType.STATE_VALUE, ""},
		LoadedAmmoVariable = {AttributeType.STATE_VALUE, ""},
		HoldingWeaponVariable = {AttributeType.STATE_VALUE, ""},
	},
	LocationCard = {
		Subtitle = {AttributeType.STRING, ""},
		Title = {AttributeType.STRING, ""},
		Active = {AttributeType.EXPRESSION, ""},
	},
	MusicController = {
		ActivePriority = {AttributeType.EXPRESSION, "1"},
		TrackId = {AttributeType.EXPRESSION, "0"},
		NoLoop = {AttributeType.BOOL, false},
		Volume = {AttributeType.NUMBER, 0.5},
		MusicType = {AttributeType.STRING, "Stealth"},
		PersistOnReload = {AttributeType.BOOL, false},
	},
}]]></ProtectedString>
						<string name="ScriptGuid">{30866FB6-26E1-42EB-A645-104FE99D34D2}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">AttributesMap</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX98052AA74C5043928CC31C083D9B7EAB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<string name="Name">SearchInfo</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX4C35FA8B13444F1CA5B91EC6B192603D">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local validator = require("./Validator")

export type ClassSearchInfo = {
	Name:				string,
	FolderPath: 		{ { string } }|{string}|string,
	FolderRelation:		"child"|"descendant",
	ImportsGlobals:		boolean,
	IsDefault: 			boolean,
	IsAbstraction:		boolean,

	ValidClasses: 		{string},

	TypeIsAttribute: 	string?,
	TypeIsName: 		boolean?,
	TypeIsParentName: 	boolean?,

	AbstractionName:	string?,

	SubTypes:			{ClassSearchInfo}?,
}

local classSearchInfo: {ClassSearchInfo} = {
	StateComponent = {
		FolderPath 			= {
			{ "StateComponents" },
			{ "StateComponentTemplates" }
		},
		ValidClasses 		= {
			"BoolValue"
		},

		FolderRelation 		= "descendant",
		ImportsGlobals 		= false,
		TypeIsAttribute 	= "Type"
	},
	ConditionalGeometry = {
		FolderPath 		= { "ConditionalGeometry" },
		ValidClasses 	= { "Model", "Folder", "BasePart" },

		FolderChild		= true
	},
	LoudSpawn = {
		FolderPath 			= { "LoudSpawns" },
		ValidClasses 		= { "BasePart" },

		FolderRelation 		= "descendant",
		TypeIsName 			= true,
		ImportsGlobals 		= false
	},
	Prop = {
		FolderPath 			= { "Props" },
		ValidClasses 		= { "BasePart" },

		FolderRelation = "descendant",
		TypeIsName 			= true
	},
	Glass = {
		FolderPath 			= { "Glass" },
		ValidClasses 		= { "BasePart" },

		FolderDescendant	= true
	},
	Link = {
		FolderPath 		= { "Cells", "Links" },
		ValidClasses 	= { "BasePart" },

		FolderRelation 	= "child",
		ImportsGlobals 	= false
	},
	Bot = { 
		FolderPath 			= { "Bots" },
		ValidClasses 		= { "BoolValue" },

		FolderRelation 		= "descendant",
		ImportsGlobals 		= false
	},
	CustomPropPart = {
		FolderPath 			= { "CustomProps" },
		ValidClasses 		= { "BasePart" },

		FolderRelation 		= "descendant",
		ImportsGlobals 		= false,
		
		SubTypes = {
			Motor = { 
				TypeIsName		= true,
				ImportsGlobals 	= false
			},
			Base = { 
				ValidClasses = { "BasePart" },

				ImportsGlobals = false, 
				TypeIsParentName = true
			}
		}
	},
	CustomItem = {
		FolderPath 		= { "CustomItems" },
		ValidClasses 	= { "Model" },

		FolderRelation 	= "child",
		ImportsGlobals	= false
	},
	CombatFlowNode = {
		FolderPath			= { "CombatFlowMap" },
		ValidClasses		= { "BasePart" },

		FolderRelation 		= "descendant",
		ImportsGlobals		= false
	}
}

validator.DefineSeachInfoRecurse(classSearchInfo)

return classSearchInfo]]></ProtectedString>
						<string name="ScriptGuid">{4C85E6AD-FD9E-46C7-98FC-103FEBE1AF54}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Builtin</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFD69BF317B11443F8606098D970486F5">
					<Properties>
						<Content name="LinkedSource"><null></null></Content>
						<ProtectedString name="Source"><![CDATA[local glut = require("../GLUt")

local Validator = {}

function Validator.FullyDefineSearchEntry(entry, optName)
	if type(optName) == "string" then entry.Name = optName end
	entry.FolderRelation = glut.default_typed(entry.FolderRelation, "descendant")
	entry.ImportsGlobals = glut.default_typed(entry.ImportsGlobals, true)
	entry.TypeIsDefault = glut.default_typed(entry.TypeIsDefault, false)
	entry.IsAbstraction = glut.default_typed(entry.IsAbstraction, false)
	return entry
end

local function type_check(arg, expectedType)
	return glut.type_check(arg, expectedType, nil, nil, glut.severity.SILENT)
end

local function table_type_check(tbl, ...)
	local first = select(1, ...)
	local n = select('#', ...)
	local anyTableValid = false
	for _, v in ipairs(first) do if v == "table" then anyTableValid = true break end end
	for _, v in pairs(tbl) do
		local vValid = false
		local vType = type(v)
		for _, validType in ipairs(first) do
			vValid = vValid or (type(v) == validType)
		end
		if not anyTableValid and vType == "table" and n > 1 then
			vValid = vValid or table_type_check(tbl, select(2, ...))
		end
		if not vValid then return false end
	end
	return true
end

function Validator.EntryIsValid(entry, optName)
	entry = Validator.FullyDefineSearchEntry(entry, optName)
	local invalid = false
	if type(entry.FolderPath) == "table" then
		invalid = not table_type_check(entry.FolderPath, {"string"}, {"string"})
	elseif type(entry.FolderPath) ~= "string" then
		invalid = true
	end
	invalid = invalid or not table_type_check(entry.ValidClasses, {"string"})
	invalid = invalid or not type_check(entry.FolderRelation, "string?")
	invalid = invalid or not type_check(entry.TypeIsAttribute, "string?")
	invalid = invalid or not type_check(entry.TypeIsName, "boolean?")
	invalid = invalid or not type_check(entry.TypeIsParentName, "boolean?")
	if entry.IsAbstraction then
		invalid = invalid or not type_check(entry.AbstractionName, "string")
	end
	invalid = invalid or not type_check(entry.SubTypes, "table?")
	return not invalid
end

function Validator.DefineSeachInfoRecurse(searchInfoGroup)
	for k, v in pairs(searchInfoGroup) do
		Validator.FullyDefineSearchEntry(v, k)
		if v.SubTypes == nil then continue end
		Validator.DefineSeachInfoRecurse(v.SubTypes)
	end
end

return Validator]]></ProtectedString>
						<string name="ScriptGuid">{F748489C-77C5-4B06-8E58-48E0E5C6D4F4}</string>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<string name="Name">Validator</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
</roblox>